/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.18.7.0 (NJsonSchema v9.10.70.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export module MbsModule {
export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class EuronextClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Fetches an Ohlcv historical time series from the Euronext website.
     * @param instrument Gets or sets an instrument specifying the data series to fetch.
     * @param adjustedDataIfPresent (optional) Gets or sets a value indicating whether to fetch an adjusted data series if possible.
     * @param isDataAdjusted (optional) Gets if data is adjusted or null if unknown. This field is determined during fetching.
     * @param timeGranularity (optional) Gets or sets the time granularity of the time series.
     * @param endofdayClosingTime (optional) Gets or sets a time-of-day to apply to the end-of-day dates during data fetching if this time is not available in data.
     * @param startDate (optional) Gets or sets the date of the first element of the time series.
     * @param endDate (optional) Gets or sets the date of the last element of the time series.
     * @return A fetched Ohlcv time series.
     */
    getOhlcv(instrument: Instrument | null, adjustedDataIfPresent: boolean | undefined, isDataAdjusted: boolean | null | undefined, timeGranularity: TimeGranularity | undefined, endofdayClosingTime: string | undefined, startDate: Date | undefined, endDate: Date | undefined): Observable<HistoricalDataReplyOfOhlcv | null> {
        let url_ = this.baseUrl + "/api/v1/data/historical/euronext/ohlcv?";
        if (instrument === undefined)
            throw new Error("The parameter 'instrument' must be defined.");
        else
            url_ += "Instrument=" + encodeURIComponent("" + instrument) + "&"; 
        if (adjustedDataIfPresent === null)
            throw new Error("The parameter 'adjustedDataIfPresent' cannot be null.");
        else if (adjustedDataIfPresent !== undefined)
            url_ += "AdjustedDataIfPresent=" + encodeURIComponent("" + adjustedDataIfPresent) + "&"; 
        if (isDataAdjusted !== undefined)
            url_ += "IsDataAdjusted=" + encodeURIComponent("" + isDataAdjusted) + "&"; 
        if (timeGranularity === null)
            throw new Error("The parameter 'timeGranularity' cannot be null.");
        else if (timeGranularity !== undefined)
            url_ += "TimeGranularity=" + encodeURIComponent("" + timeGranularity) + "&"; 
        if (endofdayClosingTime === null)
            throw new Error("The parameter 'endofdayClosingTime' cannot be null.");
        else if (endofdayClosingTime !== undefined)
            url_ += "EndofdayClosingTime=" + encodeURIComponent("" + endofdayClosingTime) + "&"; 
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOhlcv(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOhlcv(<any>response_);
                } catch (e) {
                    return <Observable<HistoricalDataReplyOfOhlcv | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<HistoricalDataReplyOfOhlcv | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetOhlcv(response: HttpResponseBase): Observable<HistoricalDataReplyOfOhlcv | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HistoricalDataReplyOfOhlcv.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ErrorDto.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ErrorDto.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HistoricalDataReplyOfOhlcv | null>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class InstrumentListClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Gets a collection of Instrument for a given list name.
     * @param listName A name of the list to get.
     * @return A collection of Instrument.
     */
    getList(listName: string): Observable<Instrument2[] | null> {
        let url_ = this.baseUrl + "/api/v1/instrumentLists/{listName}";
        if (listName === undefined || listName === null)
            throw new Error("The parameter 'listName' must be defined.");
        url_ = url_.replace("{listName}", encodeURIComponent("" + listName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetList(<any>response_);
                } catch (e) {
                    return <Observable<Instrument2[] | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<Instrument2[] | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetList(response: HttpResponseBase): Observable<Instrument2[] | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Instrument2.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ErrorDto.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ErrorDto.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = resultData500 ? ErrorDto.fromJS(resultData500) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Instrument2[] | null>(<any>null);
    }
}

/** Contains all the fields commonly used to describe an instrument. */
export class Instrument implements IInstrument {
    /** Gets or sets an optional security identifier value of the SecurityIdSource type. */
    securityId!: string;
    /** Gets or sets an optional source of the SecurityId value.
Conditionally required when SecurityId is specified. */
    securityIdSource!: InstrumentSecurityIdSource;
    /** Gets a collection of alternate security identifiers. */
    securityAlternateIdGroup?: InstrumentSecurityAlternateIdGroup | undefined;
    /** Gets or sets the instrument type. */
    type!: InstrumentType;
    /** Gets or sets the type of security using ISO 10962 standard, Classification of Financial Instruments. */
    cfi?: string | undefined;
    /** Gets or sets the optional symbol (ticker) of the security. */
    symbol?: string | undefined;
    /** Gets or sets a name of the instrument. */
    name?: string | undefined;
    /** Gets or sets an optional textual description for the instrument. */
    description?: string | undefined;
    /** Gets or sets a security exchange for the instrument. */
    exchange!: Exchange;
    /** Gets or sets a currency code of the instrument. */
    currency!: CurrencyCode;
    /** Gets or sets an exchange holiday schedule. */
    businessDayCalendar!: BusinessDayCalendar;
    /** Gets or sets the current state of the instrument&gt;. */
    securityStatus!: InstrumentSecurityStatus;
    /** Gets or sets the initial margin of the instrument. */
    margin!: number;
    /** Gets or sets the contract value factor by which price must be adjusted to determine the true nominal value of a contract.
Alternative names are contract multiplier, price multiplier. */
    factor?: number | undefined;
    /** Gets or sets the minimum price increment. Could also be used to represent tick value. */
    minPriceIncrement?: number | undefined;
    /** Gets or sets the minimum price increment amount associated with the MinPriceIncrementAmount. */
    minPriceIncrementAmount?: number | undefined;
    /** Gets or sets the position limit for the instrument. */
    positionLimit?: number | undefined;
    /** Gets or sets the number of decimal places for the instrument prices. */
    pricePrecision?: number | undefined;

    constructor(data?: IInstrument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.securityAlternateIdGroup = data.securityAlternateIdGroup && !(<any>data.securityAlternateIdGroup).toJSON ? new InstrumentSecurityAlternateIdGroup(data.securityAlternateIdGroup) : <InstrumentSecurityAlternateIdGroup>this.securityAlternateIdGroup; 
            this.exchange = data.exchange && !(<any>data.exchange).toJSON ? new Exchange(data.exchange) : <Exchange>this.exchange; 
        }
        if (!data) {
            this.securityId = "xxx";
            this.securityIdSource = InstrumentSecurityIdSource.Isin;
            this.type = InstrumentType.Undefined;
            this.exchange = new Exchange();
        }
    }

    init(data?: any) {
        if (data) {
            this.securityId = data["SecurityId"] !== undefined ? data["SecurityId"] : "xxx";
            this.securityIdSource = data["SecurityIdSource"];
            this.securityAlternateIdGroup = data["SecurityAlternateIdGroup"] ? InstrumentSecurityAlternateIdGroup.fromJS(data["SecurityAlternateIdGroup"]) : <any>undefined;
            this.type = data["Type"];
            this.cfi = data["Cfi"];
            this.symbol = data["Symbol"];
            this.name = data["Name"];
            this.description = data["Description"];
            this.exchange = data["Exchange"] ? Exchange.fromJS(data["Exchange"]) : new Exchange();
            this.currency = data["Currency"];
            this.businessDayCalendar = data["BusinessDayCalendar"];
            this.securityStatus = data["SecurityStatus"];
            this.margin = data["Margin"];
            this.factor = data["Factor"];
            this.minPriceIncrement = data["MinPriceIncrement"];
            this.minPriceIncrementAmount = data["MinPriceIncrementAmount"];
            this.positionLimit = data["PositionLimit"];
            this.pricePrecision = data["PricePrecision"];
        }
    }

    static fromJS(data: any): Instrument {
        data = typeof data === 'object' ? data : {};
        let result = new Instrument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SecurityId"] = this.securityId;
        data["SecurityIdSource"] = this.securityIdSource;
        data["SecurityAlternateIdGroup"] = this.securityAlternateIdGroup ? this.securityAlternateIdGroup.toJSON() : <any>undefined;
        data["Type"] = this.type;
        data["Cfi"] = this.cfi;
        data["Symbol"] = this.symbol;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Exchange"] = this.exchange ? this.exchange.toJSON() : <any>undefined;
        data["Currency"] = this.currency;
        data["BusinessDayCalendar"] = this.businessDayCalendar;
        data["SecurityStatus"] = this.securityStatus;
        data["Margin"] = this.margin;
        data["Factor"] = this.factor;
        data["MinPriceIncrement"] = this.minPriceIncrement;
        data["MinPriceIncrementAmount"] = this.minPriceIncrementAmount;
        data["PositionLimit"] = this.positionLimit;
        data["PricePrecision"] = this.pricePrecision;
        return data; 
    }
}

/** Contains all the fields commonly used to describe an instrument. */
export interface IInstrument {
    /** Gets or sets an optional security identifier value of the SecurityIdSource type. */
    securityId: string;
    /** Gets or sets an optional source of the SecurityId value.
Conditionally required when SecurityId is specified. */
    securityIdSource: InstrumentSecurityIdSource;
    /** Gets a collection of alternate security identifiers. */
    securityAlternateIdGroup?: IInstrumentSecurityAlternateIdGroup | undefined;
    /** Gets or sets the instrument type. */
    type: InstrumentType;
    /** Gets or sets the type of security using ISO 10962 standard, Classification of Financial Instruments
(CFI code) values.

FIX field: CFICode. */
    cfi?: string | undefined;
    /** Gets or sets the optional symbol (ticker) of the security. */
    symbol?: string | undefined;
    /** Gets or sets a name of the instrument. */
    name?: string | undefined;
    /** Gets or sets an optional textual description for the instrument. */
    description?: string | undefined;
    /** Gets or sets a security exchange for the instrument. */
    exchange: IExchange;
    /** Gets or sets a currency code of the instrument. */
    currency: CurrencyCode;
    /** Gets or sets an exchange holiday schedule. */
    businessDayCalendar: BusinessDayCalendar;
    /** Gets or sets the current state of the instrument&gt;. */
    securityStatus: InstrumentSecurityStatus;
    /** Gets or sets the initial margin of the instrument. */
    margin: number;
    /** Gets or sets the contract value factor by which price must be adjusted to determine the true nominal value of a contract.
Alternative names are contract multiplier, price multiplier. */
    factor?: number | undefined;
    /** Gets or sets the minimum price increment. Could also be used to represent tick value. */
    minPriceIncrement?: number | undefined;
    /** Gets or sets the minimum price increment amount associated with the MinPriceIncrementAmount. */
    minPriceIncrementAmount?: number | undefined;
    /** Gets or sets the position limit for the instrument. */
    positionLimit?: number | undefined;
    /** Gets or sets the number of decimal places for the instrument prices. */
    pricePrecision?: number | undefined;
}

/** Identifies a source of the security id value. */
export enum InstrumentSecurityIdSource {
    Isin = 0, 
    Cuisp = 1, 
    Sedol = 2, 
    RicCode = 3, 
    BloombergSymbol = 4, 
    BloombergOpenSymbologyBbgid = 5, 
    ExchangeSymbol = 6, 
    IsoCurrencyCode = 7, 
}

/** Contains a collection of alternate security identifiers. */
export class InstrumentSecurityAlternateIdGroup implements IInstrumentSecurityAlternateIdGroup {
    /** Gets a number of InstrumentSecurityAlternateId entries. */
    count!: number;
    /** Gets a collection of security alternate id entries. */
    collection?: InstrumentSecurityAlternateId[] | undefined;

    constructor(data?: IInstrumentSecurityAlternateIdGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.collection) {
                this.collection = [];
                for (let i = 0; i < data.collection.length; i++) {
                    let item = data.collection[i];
                    this.collection[i] = item && !(<any>item).toJSON ? new InstrumentSecurityAlternateId(item) : <InstrumentSecurityAlternateId>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.count = data["Count"];
            if (data["Collection"] && data["Collection"].constructor === Array) {
                this.collection = [];
                for (let item of data["Collection"])
                    this.collection.push(InstrumentSecurityAlternateId.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InstrumentSecurityAlternateIdGroup {
        data = typeof data === 'object' ? data : {};
        let result = new InstrumentSecurityAlternateIdGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Count"] = this.count;
        if (this.collection && this.collection.constructor === Array) {
            data["Collection"] = [];
            for (let item of this.collection)
                data["Collection"].push(item.toJSON());
        }
        return data; 
    }
}

/** Contains a collection of alternate security identifiers. */
export interface IInstrumentSecurityAlternateIdGroup {
    /** Gets a number of InstrumentSecurityAlternateId entries. */
    count: number;
    /** Gets a collection of security alternate id entries. */
    collection?: IInstrumentSecurityAlternateId[] | undefined;
}

/** Contains an alternate security identifier value of the specified source. */
export class InstrumentSecurityAlternateId implements IInstrumentSecurityAlternateId {
    /** Gets an alternate security identifier value of the SecurityAlternateIdSource type. */
    securityAlternateId?: string | undefined;
    /** Gets the source of the SecurityAlternateId value. */
    securityAlternateIdSource!: InstrumentSecurityIdSource;

    constructor(data?: IInstrumentSecurityAlternateId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.securityAlternateId = data["SecurityAlternateId"];
            this.securityAlternateIdSource = data["SecurityAlternateIdSource"];
        }
    }

    static fromJS(data: any): InstrumentSecurityAlternateId {
        data = typeof data === 'object' ? data : {};
        let result = new InstrumentSecurityAlternateId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["SecurityAlternateId"] = this.securityAlternateId;
        data["SecurityAlternateIdSource"] = this.securityAlternateIdSource;
        return data; 
    }
}

/** Contains an alternate security identifier value of the specified source. */
export interface IInstrumentSecurityAlternateId {
    /** Gets an alternate security identifier value of the SecurityAlternateIdSource type. */
    securityAlternateId?: string | undefined;
    /** Gets the source of the SecurityAlternateId value. */
    securityAlternateIdSource: InstrumentSecurityIdSource;
}

/** Identifies instrument types. */
export enum InstrumentType {
    Undefined = 0, 
    Index = 1, 
    Stock = 2, 
    Etf = 3, 
    Etv = 4, 
    Inav = 5, 
    Fund = 6, 
    Option = 7, 
    Future = 8, 
    Cfd = 9, 
    Forex = 10, 
    Crypto = 11, 
}

/** ISO 10383 Market Identifier Code (MIC) utilities. */
export class Exchange implements IExchange {
    /** Gets or sets an ISO 10383 Market Identifier Code (MIC). */
    mic!: ExchangeMic;
    /** Gets the time zone. */
    timeZone!: string;
    /** Gets a value indicating whether this exchange belongs to the Euronext family. */
    isEuronext!: boolean;
    /** Gets the country. */
    country!: ExchangeCountry;

    constructor(data?: IExchange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mic = ExchangeMic.Xams;
        }
    }

    init(data?: any) {
        if (data) {
            this.mic = data["Mic"];
            this.timeZone = data["TimeZone"];
            this.isEuronext = data["IsEuronext"];
            this.country = data["Country"];
        }
    }

    static fromJS(data: any): Exchange {
        data = typeof data === 'object' ? data : {};
        let result = new Exchange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Mic"] = this.mic;
        data["TimeZone"] = this.timeZone;
        data["IsEuronext"] = this.isEuronext;
        data["Country"] = this.country;
        return data; 
    }
}

/** ISO 10383 Market Identifier Code (MIC) utilities. */
export interface IExchange {
    /** Gets or sets an ISO 10383 Market Identifier Code (MIC). */
    mic: ExchangeMic;
    /** Gets the time zone. */
    timeZone: string;
    /** Gets a value indicating whether this exchange belongs to the Euronext family. */
    isEuronext: boolean;
    /** Gets the country. */
    country: ExchangeCountry;
}

/** Exchange representations according to ISO 10383 Market Identifier Code (MIC). */
export enum ExchangeMic {
    Egsi = 0, 
    Xwbo = 1, 
    Exaa = 2, 
    Wbah = 3, 
    Wbdm = 4, 
    Wbgf = 5, 
    Xvie = 6, 
    Beam = 7, 
    Bmts = 8, 
    Mtsd = 9, 
    Mtsf = 10, 
    Blpx = 11, 
    Xbru = 12, 
    Alxb = 13, 
    Enxb = 14, 
    Mlxb = 15, 
    Tnlb = 16, 
    Vpxb = 17, 
    Xbrd = 18, 
    Cand = 19, 
    Canx = 20, 
    Chic = 21, 
    Xcx2 = 22, 
    Cotc = 23, 
    Ifca = 24, 
    Ivzx = 25, 
    Lica = 26, 
    Matn = 27, 
    Neoe = 28, 
    Ngxc = 29, 
    Omga = 30, 
    Lynx = 31, 
    Tmxs = 32, 
    Xats = 33, 
    Xbbk = 34, 
    Xcnq = 35, 
    Pure = 36, 
    Xcxd = 37, 
    Xicx = 38, 
    Xmoc = 39, 
    Xmod = 40, 
    Xtse = 41, 
    Xtsx = 42, 
    Xtnx = 43, 
    Dasi = 44, 
    Dktc = 45, 
    Gxgr = 46, 
    Gxgf = 47, 
    Gxgm = 48, 
    Jbsi = 49, 
    Npga = 50, 
    Snsi = 51, 
    Xcse = 52, 
    Dcse = 53, 
    Fndk = 54, 
    Dndk = 55, 
    Mcse = 56, 
    Mndk = 57, 
    Fgex = 58, 
    Xhel = 59, 
    Fnfi = 60, 
    Dhel = 61, 
    Dnfi = 62, 
    Mhel = 63, 
    Mnfi = 64, 
    Coal = 65, 
    Epex = 66, 
    Exse = 67, 
    Fmts = 68, 
    Gmtf = 69, 
    Lchc = 70, 
    Natx = 71, 
    Xafr = 72, 
    Xbln = 73, 
    Xpar = 74, 
    Alxp = 75, 
    Mtch = 76, 
    Xmat = 77, 
    Xmli = 78, 
    Xmon = 79, 
    Xspm = 80, 
    Xpow = 81, 
    Xpsf = 82, 
    Xpot = 83, 
    X360T = 84, 
    Baad = 85, 
    Cats = 86, 
    Dapa = 87, 
    Dbox = 88, 
    Auto = 89, 
    Ecag = 90, 
    Ficx = 91, 
    Hsbt = 92, 
    Tgat = 93, 
    Xgat = 94, 
    Xgrm = 95, 
    Vwdx = 96, 
    Xber = 97, 
    Bera = 98, 
    Berb = 99, 
    Berc = 100, 
    Eqta = 101, 
    Eqtb = 102, 
    Eqtc = 103, 
    Eqtd = 104, 
    Xeqt = 105, 
    Zobx = 106, 
    Xdus = 107, 
    Dusa = 108, 
    Dusb = 109, 
    Dusc = 110, 
    Dusd = 111, 
    Xqtx = 112, 
    Xecb = 113, 
    Xecc = 114, 
    Xeee = 115, 
    Xeeo = 116, 
    Xeer = 117, 
    Xetr = 118, 
    Xeub = 119, 
    Xeta = 120, 
    Xetb = 121, 
    Xeup = 122, 
    Xeum = 123, 
    Xere = 124, 
    Xert = 125, 
    Xeur = 126, 
    Xfra = 127, 
    Fraa = 128, 
    Frab = 129, 
    Xdbc = 130, 
    Xdbv = 131, 
    Xdbx = 132, 
    Xham = 133, 
    Hama = 134, 
    Hamb = 135, 
    Hamm = 136, 
    Hamn = 137, 
    Haml = 138, 
    Xhan = 139, 
    Hana = 140, 
    Hanb = 141, 
    Xinv = 142, 
    Xmun = 143, 
    Muna = 144, 
    Munb = 145, 
    Mund = 146, 
    Munc = 147, 
    Xsco = 148, 
    Xsc1 = 149, 
    Xsc2 = 150, 
    Xsc3 = 151, 
    Xstu = 152, 
    Euwx = 153, 
    Stua = 154, 
    Stub = 155, 
    Xstf = 156, 
    Stuc = 157, 
    Stud = 158, 
    Xxsc = 159, 
    Xice = 160, 
    Dice = 161, 
    Fnis = 162, 
    Dnis = 163, 
    Mice = 164, 
    Mnis = 165, 
    Cgit = 166, 
    Cggd = 167, 
    Cgcm = 168, 
    Cgqt = 169, 
    Cgdb = 170, 
    Cgeb = 171, 
    Cgtr = 172, 
    Cgqd = 173, 
    Cgnd = 174, 
    Emid = 175, 
    Emdr = 176, 
    Emir = 177, 
    Emib = 178, 
    Etlx = 179, 
    Fbsi = 180, 
    Hmtf = 181, 
    Hmod = 182, 
    Hrfq = 183, 
    Mtso = 184, 
    Bond = 185, 
    Mtsc = 186, 
    Mtsm = 187, 
    Ssob = 188, 
    Xgme = 189, 
    Xmil = 190, 
    Mtah = 191, 
    Etfp = 192, 
    Mivx = 193, 
    Motx = 194, 
    Mtaa = 195, 
    Sedx = 196, 
    Xaim = 197, 
    Xdmi = 198, 
    Xmot = 199, 
    Cclx = 200, 
    Mibl = 201, 
    Rbcb = 202, 
    Rbsi = 203, 
    Xlux = 204, 
    Emtf = 205, 
    Xves = 206, 
    Fish = 207, 
    Fshx = 208, 
    Icas = 209, 
    Nexo = 210, 
    Nops = 211, 
    Norx = 212, 
    Eleu = 213, 
    Else = 214, 
    Elno = 215, 
    Eluk = 216, 
    Frei = 217, 
    Bulk = 218, 
    Stee = 219, 
    Nosc = 220, 
    Notc = 221, 
    Oslc = 222, 
    Xdnb = 223, 
    Xima = 224, 
    Xosl = 225, 
    Xoam = 226, 
    Xoas = 227, 
    Nibr = 228, 
    Merd = 229, 
    Merk = 230, 
    Xosc = 231, 
    Xoad = 232, 
    Xosd = 233, 
    Omic = 234, 
    Opex = 235, 
    Xlis = 236, 
    Alxl = 237, 
    Enxl = 238, 
    Mfox = 239, 
    Omip = 240, 
    Wqxl = 241, 
    Bmex = 242, 
    Mabx = 243, 
    Send = 244, 
    Xbar = 245, 
    Xbil = 246, 
    Xdrf = 247, 
    Xlat = 248, 
    Xmad = 249, 
    Xmce = 250, 
    Xmrv = 251, 
    Xval = 252, 
    Merf = 253, 
    Xmpw = 254, 
    Marf = 255, 
    Bmcl = 256, 
    Sbar = 257, 
    Sbil = 258, 
    Bmea = 259, 
    Ibgh = 260, 
    Mibg = 261, 
    Omel = 262, 
    Pave = 263, 
    Xdpa = 264, 
    Xnaf = 265, 
    Cryd = 266, 
    Cryx = 267, 
    Napa = 268, 
    Sebx = 269, 
    Ensx = 270, 
    Sebs = 271, 
    Xngm = 272, 
    Nmtf = 273, 
    Xndx = 274, 
    Xnmr = 275, 
    Xsat = 276, 
    Xsto = 277, 
    Fnse = 278, 
    Xopv = 279, 
    Csto = 280, 
    Dsto = 281, 
    Dnse = 282, 
    Msto = 283, 
    Mnse = 284, 
    Dked = 285, 
    Fied = 286, 
    Noed = 287, 
    Seed = 288, 
    Pned = 289, 
    Euwb = 290, 
    Uswb = 291, 
    Dkfi = 292, 
    Nofi = 293, 
    Ebon = 294, 
    Onse = 295, 
    Esto = 296, 
    Aixe = 297, 
    Dots = 298, 
    Ebss = 299, 
    Ebsc = 300, 
    Euch = 301, 
    Eusp = 302, 
    Eurm = 303, 
    Eusc = 304, 
    S3fm = 305, 
    Stox = 306, 
    Xscu = 307, 
    Xstv = 308, 
    Xstx = 309, 
    Ubsg = 310, 
    Ubsf = 311, 
    Ubsc = 312, 
    Vlex = 313, 
    Xbrn = 314, 
    Xswx = 315, 
    Xqmh = 316, 
    Xvtx = 317, 
    Xbtr = 318, 
    Xswm = 319, 
    Xsls = 320, 
    Xicb = 321, 
    Zkbx = 322, 
    Kmux = 323, 
    Clmx = 324, 
    Hchc = 325, 
    Ndex = 326, 
    Imco = 327, 
    Imeq = 328, 
    Ndxs = 329, 
    Nlpx = 330, 
    Xams = 331, 
    Tnla = 332, 
    Xeuc = 333, 
    Xeue = 334, 
    Xeui = 335, 
    Xems = 336, 
    Xnxc = 337, 
    X3579 = 338, 
    Afdl = 339, 
    Ampx = 340, 
    Anzl = 341, 
    Aqxe = 342, 
    Arax = 343, 
    Atlb = 344, 
    Autx = 345, 
    Autp = 346, 
    Autb = 347, 
    Balt = 348, 
    Bltx = 349, 
    Bapa = 350, 
    Bcrm = 351, 
    Baro = 352, 
    Bark = 353, 
    Bart = 354, 
    Bcxe = 355, 
    Bate = 356, 
    Chix = 357, 
    Batd = 358, 
    Chid = 359, 
    Batf = 360, 
    Chio = 361, 
    Batp = 362, 
    Botc = 363, 
    Lisx = 364, 
    Bgci = 365, 
    Bgcb = 366, 
    Bkln = 367, 
    Bklf = 368, 
    Blox = 369, 
    Bmtf = 370, 
    Boat = 371, 
    Bosc = 372, 
    Brnx = 373, 
    Btee = 374, 
    Ebsm = 375, 
    Ebsd = 376, 
    Ebsi = 377, 
    Nexy = 378, 
    Ccml = 379, 
    Cco2 = 380, 
    Cgme = 381, 
    Chev = 382, 
    Blnk = 383, 
    Cmee = 384, 
    Cmec = 385, 
    Cmed = 386, 
    Cmmt = 387, 
    Cryp = 388, 
    Cseu = 389, 
    Cscf = 390, 
    Csbx = 391, 
    Sics = 392, 
    Csin = 393, 
    Cssi = 394, 
    Dbes = 395, 
    Dbix = 396, 
    Dbdc = 397, 
    Dbcx = 398, 
    Dbcr = 399, 
    Dbmo = 400, 
    Dbse = 401, 
    Dowg = 402, 
    Echo = 403, 
    Embx = 404, 
    Encl = 405, 
    Eqld = 406, 
    Exeu = 407, 
    Exmp = 408, 
    Exor = 409, 
    Exvp = 410, 
    Exbo = 411, 
    Exlp = 412, 
    Exdc = 413, 
    Exsi = 414, 
    Excp = 415, 
    Exot = 416, 
    Fair = 417, 
    Fisu = 418, 
    Fxgb = 419, 
    Gemx = 420, 
    Gfic = 421, 
    Gfif = 422, 
    Gfin = 423, 
    Gfir = 424, 
    Gmeg = 425, 
    Xldx = 426, 
    Xgdx = 427, 
    Xgsx = 428, 
    Xgcx = 429, 
    Grif = 430, 
    Grio = 431, 
    Grse = 432, 
    Gsib = 433, 
    Bisi = 434, 
    Gsil = 435, 
    Gssi = 436, 
    Gsbx = 437, 
    Hpcs = 438, 
    Hsbc = 439, 
    Ibal = 440, 
    Icap = 441, 
    Icah = 442, 
    Icen = 443, 
    Icse = 444, 
    Ictq = 445, 
    Wclk = 446, 
    Igdl = 447, 
    Ifeu = 448, 
    Cxrt = 449, 
    Iflo = 450, 
    Ifll = 451, 
    Ifut = 452, 
    Iflx = 453, 
    Ifen = 454, 
    Cxot = 455, 
    Ifls = 456, 
    Inve = 457, 
    Iswa = 458, 
    Jpcb = 459, 
    Jpsi = 460, 
    Jssi = 461, 
    Kleu = 462, 
    Lcur = 463, 
    Liqu = 464, 
    Liqh = 465, 
    Liqf = 466, 
    Lmax = 467, 
    Lmad = 468, 
    Lmae = 469, 
    Lmaf = 470, 
    Lmao = 471, 
    Lmec = 472, 
    Lotc = 473, 
    Pldx = 474, 
    Lppm = 475, 
    Mael = 476, 
    Mcur = 477, 
    Mcxs = 478, 
    Mcxr = 479, 
    Mfgl = 480, 
    Mfxc = 481, 
    Mfxa = 482, 
    Mfxr = 483, 
    Mhip = 484, 
    Mlxn = 485, 
    Mlax = 486, 
    Mleu = 487, 
    Mlve = 488, 
    Msip = 489, 
    Mssi = 490, 
    Mufp = 491, 
    Muti = 492, 
    Mytr = 493, 
    N2Ex = 494, 
    Ndcm = 495, 
    Nexs = 496, 
    Nexx = 497, 
    Nexf = 498, 
    Nexg = 499, 
    Next = 500, 
    Nexn = 501, 
    Nexd = 502, 
    Nexl = 503, 
    Noff = 504, 
    Nosi = 505, 
    Nuro = 506, 
    Xnlx = 507, 
    Nurd = 508, 
    Nxeu = 509, 
    Otce = 510, 
    Peel = 511, 
    Xrsp = 512, 
    Xphx = 513, 
    Pieu = 514, 
    Pirm = 515, 
    Ppex = 516, 
    Qwix = 517, 
    Rbce = 518, 
    Rbct = 519, 
    Rtsi = 520, 
    Rbsx = 521, 
    Rtsl = 522, 
    Trfw = 523, 
    Tral = 524, 
    Secf = 525, 
    Sedr = 526, 
    Sgmx = 527, 
    Sgmy = 528, 
    Shar = 529, 
    Spec = 530, 
    Sprz = 531, 
    Ssex = 532, 
    Stal = 533, 
    Stan = 534, 
    Stsi = 535, 
    Swap = 536, 
    Tcml = 537, 
    Tfsv = 538, 
    Fxop = 539, 
    Tpie = 540, 
    Trax = 541, 
    Trde = 542, 
    Nave = 543, 
    Tcds = 544, 
    Trdx = 545, 
    Tfsg = 546, 
    Parx = 547, 
    Elix = 548, 
    Treu = 549, 
    Trea = 550, 
    Treo = 551, 
    Trqx = 552, 
    Trqm = 553, 
    Trqs = 554, 
    Trqa = 555, 
    Trsi = 556, 
    Ubsb = 557, 
    Ubsy = 558, 
    Ubsl = 559, 
    Ubse = 560, 
    Ubsi = 561, 
    Ukpx = 562, 
    Vcmo = 563, 
    Vega = 564, 
    Wins = 565, 
    Winx = 566, 
    Xalt = 567, 
    Xcor = 568, 
    Xgcl = 569, 
    Xlbm = 570, 
    Xlch = 571, 
    Xldn = 572, 
    Xsmp = 573, 
    Ensy = 574, 
    Xlme = 575, 
    Xlon = 576, 
    Aimx = 577, 
    Xlod = 578, 
    Xlom = 579, 
    Xmts = 580, 
    Hung = 581, 
    Ukgd = 582, 
    Amts = 583, 
    Emts = 584, 
    Gmts = 585, 
    Imts = 586, 
    Mczk = 587, 
    Mtsa = 588, 
    Mtsg = 589, 
    Mtss = 590, 
    Rmts = 591, 
    Smts = 592, 
    Vmts = 593, 
    Bvuk = 594, 
    Port = 595, 
    Mtsw = 596, 
    Xsga = 597, 
    Xswb = 598, 
    Xtup = 599, 
    Tpeq = 600, 
    Tben = 601, 
    Tbla = 602, 
    Tpcd = 603, 
    Tpfd = 604, 
    Tpre = 605, 
    Tpsd = 606, 
    Xtpe = 607, 
    Tpel = 608, 
    Tpsl = 609, 
    Xubs = 610, 
    Aats = 611, 
    Advt = 612, 
    Aqua = 613, 
    Atdf = 614, 
    Core = 615, 
    Baml = 616, 
    Mlvx = 617, 
    Mlco = 618, 
    Barx = 619, 
    Bard = 620, 
    Barl = 621, 
    Bcdx = 622, 
    Bats = 623, 
    Bato = 624, 
    Baty = 625, 
    Bzxd = 626, 
    Byxd = 627, 
    Bbsf = 628, 
    Bgcf = 629, 
    Fncs = 630, 
    Bgcd = 631, 
    Bhsf = 632, 
    Bids = 633, 
    Bltd = 634, 
    Bpol = 635, 
    Bnyc = 636, 
    Vtex = 637, 
    Nyfx = 638, 
    Btec = 639, 
    Icsu = 640, 
    Cded = 641, 
    Cgmi = 642, 
    Cicx = 643, 
    Lqfi = 644, 
    Cblc = 645, 
    Cmsf = 646, 
    Cred = 647, 
    Caes = 648, 
    Cslp = 649, 
    Dbsx = 650, 
    Deal = 651, 
    Edge = 652, 
    Eddp = 653, 
    Edga = 654, 
    Edgd = 655, 
    Edgx = 656, 
    Edgo = 657, 
    Egmt = 658, 
    Eris = 659, 
    Fast = 660, 
    Finr = 661, 
    Finn = 662, 
    Fino = 663, 
    Finy = 664, 
    Xadf = 665, 
    Ootc = 666, 
    Fsef = 667, 
    Fxal = 668, 
    Fxcm = 669, 
    G1xx = 670, 
    Gllc = 671, 
    Glps = 672, 
    Glpx = 673, 
    Gotc = 674, 
    Govx = 675, 
    Gree = 676, 
    Gsco = 677, 
    Sgmt = 678, 
    Gsef = 679, 
    Gtco = 680, 
    Gtsx = 681, 
    Gtxs = 682, 
    Hegx = 683, 
    Hppo = 684, 
    Hsfx = 685, 
    Icel = 686, 
    Iexg = 687, 
    Iexd = 688, 
    Ifus = 689, 
    Iepa = 690, 
    Imfx = 691, 
    Imag = 692, 
    Imbd = 693, 
    Imcr = 694, 
    Imen = 695, 
    Imir = 696, 
    Ifed = 697, 
    Imcg = 698, 
    Imcc = 699, 
    Ices = 700, 
    Imcs = 701, 
    Isda = 702, 
    Itgi = 703, 
    Jefx = 704, 
    Jlqd = 705, 
    Jpbx = 706, 
    Jpmx = 707, 
    Jses = 708, 
    Jsjx = 709, 
    Knig = 710, 
    Kncm = 711, 
    Knem = 712, 
    Knli = 713, 
    Knmx = 714, 
    Ackf = 715, 
    Lasf = 716, 
    Ledg = 717, 
    Levl = 718, 
    Lius = 719, 
    Lifi = 720, 
    Liuh = 721, 
    Lqed = 722, 
    Ltaa = 723, 
    Lmnx = 724, 
    Mihi = 725, 
    Xmio = 726, 
    Mprl = 727, 
    Msco = 728, 
    Mspl = 729, 
    Msrp = 730, 
    Mstx = 731, 
    Mslp = 732, 
    Mtus = 733, 
    Bvus = 734, 
    Mtsb = 735, 
    Mtxx = 736, 
    Mtxs = 737, 
    Mtxm = 738, 
    Mtxc = 739, 
    Mtxa = 740, 
    Nblx = 741, 
    Nfsc = 742, 
    Nfsa = 743, 
    Nfsd = 744, 
    Xstm = 745, 
    Nmra = 746, 
    Nodx = 747, 
    Nxus = 748, 
    Nypc = 749, 
    Ollc = 750, 
    Opra = 751, 
    Otcm = 752, 
    Otcb = 753, 
    Otcq = 754, 
    Pinc = 755, 
    Pini = 756, 
    Pinl = 757, 
    Pinx = 758, 
    Psgm = 759, 
    Cave = 760, 
    Pdqx = 761, 
    Pdqd = 762, 
    Pipe = 763, 
    Prse = 764, 
    Pulx = 765, 
    Ricx = 766, 
    Ricd = 767, 
    Scxs = 768, 
    Sgma = 769, 
    Shaw = 770, 
    Shad = 771, 
    Soho = 772, 
    Sstx = 773, 
    Tera = 774, 
    Tfsu = 775, 
    Them = 776, 
    Thre = 777, 
    Tmid = 778, 
    Tpse = 779, 
    Trck = 780, 
    Trux = 781, 
    Tru1 = 782, 
    Tru2 = 783, 
    Trwb = 784, 
    Bndd = 785, 
    Twsf = 786, 
    Dwsf = 787, 
    Tsad = 788, 
    Tsbx = 789, 
    Tsef = 790, 
    Ubsa = 791, 
    Ubsp = 792, 
    Vert = 793, 
    Vfcm = 794, 
    Virt = 795, 
    Weed = 796, 
    Xwee = 797, 
    Welx = 798, 
    Wsag = 799, 
    Xaqs = 800, 
    Xbox = 801, 
    Xcbo = 802, 
    C2Ox = 803, 
    Cbsx = 804, 
    Xcbf = 805, 
    Xcbt = 806, 
    Fcbt = 807, 
    Xkbt = 808, 
    Xcff = 809, 
    Xchi = 810, 
    Xcis = 811, 
    Xcme = 812, 
    Fcme = 813, 
    Glbx = 814, 
    Ximm = 815, 
    Xiom = 816, 
    Nyms = 817, 
    Cmes = 818, 
    Cbts = 819, 
    Cecs = 820, 
    Xcur = 821, 
    Xelx = 822, 
    Xfci = 823, 
    Xgmx = 824, 
    Xins = 825, 
    Iblx = 826, 
    Icbx = 827, 
    Icro = 828, 
    Iidx = 829, 
    Rcbx = 830, 
    Mocx = 831, 
    Xisx = 832, 
    Xisa = 833, 
    Xise = 834, 
    Mcry = 835, 
    Gmni = 836, 
    Xmer = 837, 
    Xmge = 838, 
    Xnas = 839, 
    Xbxo = 840, 
    Bosd = 841, 
    Nasd = 842, 
    Xbrt = 843, 
    Xncm = 844, 
    Xndq = 845, 
    Xngs = 846, 
    Xnim = 847, 
    Xnms = 848, 
    Xpbt = 849, 
    Xphl = 850, 
    Xpho = 851, 
    Xpor = 852, 
    Xpsx = 853, 
    Espd = 854, 
    Xbos = 855, 
    Xnym = 856, 
    Xcec = 857, 
    Xnye = 858, 
    Xnyl = 859, 
    Xnys = 860, 
    Aldp = 861, 
    Amxo = 862, 
    Arcd = 863, 
    Arco = 864, 
    Arcx = 865, 
    Nysd = 866, 
    Xase = 867, 
    Xnli = 868, 
    Xoch = 869, 
    Xotc = 870, 
    Xsef = 871, 
    Bilt = 872, 
    Xoff = 873, 
    Xxxx = 874, 
}

/** Exchange countries related to ISO 10383 Market Identifier Codes. */
export enum ExchangeCountry {
    NoCountry = 0, 
    Austria = 1, 
    Belgium = 2, 
    Canada = 3, 
    Denmark = 4, 
    Finland = 5, 
    France = 6, 
    Germany = 7, 
    Iceland = 8, 
    Italy = 9, 
    Luxembourg = 10, 
    Norway = 11, 
    Portugal = 12, 
    Spain = 13, 
    Sweden = 14, 
    Switzerland = 15, 
    Netherlands = 16, 
    UnitedKingdom = 17, 
    UnitedStates = 18, 
}

/** Currency representations according to ISO 4217. */
export enum CurrencyCode {
    Xxx = 0, 
    Ars = 1, 
    Aud = 2, 
    Brl = 3, 
    Cad = 4, 
    Chf = 5, 
    Clp = 6, 
    Cny = 7, 
    Czk = 8, 
    Dkk = 9, 
    Eur = 10, 
    Gbp = 11, 
    Gbx = 12, 
    Hkd = 13, 
    Huf = 14, 
    Ils = 15, 
    Inr = 16, 
    Isk = 17, 
    Jpy = 18, 
    Krw = 19, 
    Mxn = 20, 
    Nok = 21, 
    Nzd = 22, 
    Pln = 23, 
    Ron = 24, 
    Rub = 25, 
    Sek = 26, 
    Sgd = 27, 
    Try = 28, 
    Twd = 29, 
    Usd = 30, 
    Xag = 31, 
    Xau = 32, 
    Xpd = 33, 
    Xpt = 34, 
    Xts = 35, 
    Zar = 36, 
    Xbt = 37, 
    Xbc = 38, 
    Xlm = 39, 
    Xmr = 40, 
    Xrp = 41, 
    Dsh = 42, 
    Eth = 43, 
    Vtc = 44, 
    Zec = 45, 
}

/** Provides a specific exchange holiday schedule or a general country holiday schedule. */
export enum BusinessDayCalendar {
    Target = 0, 
    WeekendsOnly = 1, 
    NoHolidays = 2, 
    Euronext = 3, 
    UnitedStates = 4, 
    Switzerland = 5, 
    Sweden = 6, 
    Denmark = 7, 
    Norway = 8, 
}

/** Denotes the current state of the instrument. */
export enum InstrumentSecurityStatus {
    Active = 0, 
    ActiveClosingOrdersOnly = 1, 
    Inactive = 2, 
    Suspended = 3, 
    PendingExpiry = 4, 
    Expired = 5, 
    PendingDeletion = 6, 
    Delisted = 7, 
    KnockedOut = 8, 
    KnockOutRevoked = 9, 
}

/** Enumerates predefined time granularities. */
export enum TimeGranularity {
    Aperiodic = 0, 
    Second1 = 1, 
    Second2 = 2, 
    Second3 = 3, 
    Second4 = 4, 
    Second5 = 5, 
    Second6 = 6, 
    Second10 = 7, 
    Second12 = 8, 
    Second15 = 9, 
    Second20 = 10, 
    Second30 = 11, 
    Minute1 = 12, 
    Minute2 = 13, 
    Minute3 = 14, 
    Minute4 = 15, 
    Minute5 = 16, 
    Minute6 = 17, 
    Minute10 = 18, 
    Minute12 = 19, 
    Minute15 = 20, 
    Minute20 = 21, 
    Minute30 = 22, 
    Hour1 = 23, 
    Hour2 = 24, 
    Hour3 = 25, 
    Hour4 = 26, 
    Hour6 = 27, 
    Hour8 = 28, 
    Hour12 = 29, 
    Day1 = 30, 
    Week1 = 31, 
    Week2 = 32, 
    Week3 = 33, 
    Month1 = 34, 
    Month2 = 35, 
    Month3 = 36, 
    Month4 = 37, 
    Month6 = 38, 
    Year1 = 39, 
}

export class HistoricalDataReplyOfOhlcv implements IHistoricalDataReplyOfOhlcv {
    isDataAdjusted?: boolean | undefined;
    data?: Ohlcv[] | undefined;

    constructor(data?: IHistoricalDataReplyOfOhlcv) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.data) {
                this.data = [];
                for (let i = 0; i < data.data.length; i++) {
                    let item = data.data[i];
                    this.data[i] = item && !(<any>item).toJSON ? new Ohlcv(item) : <Ohlcv>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDataAdjusted = data["IsDataAdjusted"];
            if (data["Data"] && data["Data"].constructor === Array) {
                this.data = [];
                for (let item of data["Data"])
                    this.data.push(Ohlcv.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HistoricalDataReplyOfOhlcv {
        data = typeof data === 'object' ? data : {};
        let result = new HistoricalDataReplyOfOhlcv();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsDataAdjusted"] = this.isDataAdjusted;
        if (this.data && this.data.constructor === Array) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IHistoricalDataReplyOfOhlcv {
    isDataAdjusted?: boolean | undefined;
    data?: IOhlcv[] | undefined;
}

/** An [open, high, low, close, volume] bar. */
export class Ohlcv implements IOhlcv {
    /** Gets or sets the opening price. */
    open!: number;
    /** Gets or sets the highest price. */
    high!: number;
    /** Gets or sets the lowest price. */
    low!: number;
    /** Gets or sets the closing price. */
    close!: number;
    /** Gets or sets the volume. */
    volume!: number;
    /** Gets or sets the date and time. For Ohlcv bar entities it corresponds to the Close time, so that an Ohlcv bar accumulates lower-level entities up to the closing date and time. */
    time!: Date;

    constructor(data?: IOhlcv) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.open = data["Open"];
            this.high = data["High"];
            this.low = data["Low"];
            this.close = data["Close"];
            this.volume = data["Volume"];
            this.time = data["time"] ? new Date(data["time"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Ohlcv {
        data = typeof data === 'object' ? data : {};
        let result = new Ohlcv();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Open"] = this.open;
        data["High"] = this.high;
        data["Low"] = this.low;
        data["Close"] = this.close;
        data["Volume"] = this.volume;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        return data; 
    }
}

/** An [open, high, low, close, volume] bar. */
export interface IOhlcv {
    /** Gets or sets the opening price. */
    open: number;
    /** Gets or sets the highest price. */
    high: number;
    /** Gets or sets the lowest price. */
    low: number;
    /** Gets or sets the closing price. */
    close: number;
    /** Gets or sets the volume. */
    volume: number;
    /** Gets or sets the date and time. For Ohlcv bar entities it corresponds to the Close time, so that an Ohlcv bar accumulates lower-level entities up to the closing date and time. */
    time: Date;
}

/** Encapsulates an error. */
export class ErrorDto implements IErrorDto {
    /** Gets or sets the status code of the error. */
    statusCode!: number;
    /** Gets or sets a human-readable representation of the error. */
    message?: string | undefined;
    /** Gets or sets inner errors of this error. */
    details?: InnerError[] | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.details) {
                this.details = [];
                for (let i = 0; i < data.details.length; i++) {
                    let item = data.details[i];
                    this.details[i] = item && !(<any>item).toJSON ? new InnerError(item) : <InnerError>item;
                }
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.statusCode = data["StatusCode"];
            this.message = data["Message"];
            if (data["Details"] && data["Details"].constructor === Array) {
                this.details = [];
                for (let item of data["Details"])
                    this.details.push(InnerError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StatusCode"] = this.statusCode;
        data["Message"] = this.message;
        if (this.details && this.details.constructor === Array) {
            data["Details"] = [];
            for (let item of this.details)
                data["Details"].push(item.toJSON());
        }
        return data; 
    }
}

/** Encapsulates an error. */
export interface IErrorDto {
    /** Gets or sets the status code of the error. */
    statusCode: number;
    /** Gets or sets a human-readable representation of the error. */
    message?: string | undefined;
    /** Gets or sets inner errors of this error. */
    details?: IInnerError[] | undefined;
}

/** The recursive inner error. */
export class InnerError implements IInnerError {
    /** Gets or sets the message of an inner error. */
    message?: string | undefined;
    /** Gets or sets inner errors of this inner error. */
    details?: InnerError | undefined;

    constructor(data?: IInnerError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.details = data.details && !(<any>data.details).toJSON ? new InnerError(data.details) : <InnerError>this.details; 
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["Message"];
            this.details = data["Details"] ? InnerError.fromJS(data["Details"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InnerError {
        data = typeof data === 'object' ? data : {};
        let result = new InnerError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["Details"] = this.details ? this.details.toJSON() : <any>undefined;
        return data; 
    }
}

/** The recursive inner error. */
export interface IInnerError {
    /** Gets or sets the message of an inner error. */
    message?: string | undefined;
    /** Gets or sets inner errors of this inner error. */
    details?: IInnerError | undefined;
}

/** Contains information to describe an instrument. */
export class Instrument2 implements IInstrument2 {
    /** Gets or sets the optional symbol (ticker) of the security. */
    symbol?: string | undefined;
    /** Gets or sets a name of the instrument. */
    name?: string | undefined;
    /** Gets or sets an optional textual description for the instrument. */
    description?: string | undefined;
    /** Gets or sets the instrument type. */
    type!: InstrumentType;
    /** Gets or sets an exchange representations according to ISO 10383 Market Identifier Code (MIC). */
    mic!: ExchangeMic;
    /** Gets or sets an ISIN. */
    isin?: string | undefined;
    /** Gets or sets an additional information for stocks. */
    stock?: Stock | undefined;
    /** Gets or sets an additional information for Exchange-Traded Vehicles. */
    etv?: Etv | undefined;
    /** Gets or sets an additional information for Exchange-Traded Funds. */
    etf?: Etf | undefined;
    /** Gets or sets an additional information for Indicative Net Asset Values. */
    inav?: Inav | undefined;
    /** Gets or sets an additional information for funds. */
    fund?: Fund | undefined;
    /** Gets or sets an additional information for indices. */
    index?: Index | undefined;

    constructor(data?: IInstrument2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.stock = data.stock && !(<any>data.stock).toJSON ? new Stock(data.stock) : <Stock>this.stock; 
            this.etv = data.etv && !(<any>data.etv).toJSON ? new Etv(data.etv) : <Etv>this.etv; 
            this.etf = data.etf && !(<any>data.etf).toJSON ? new Etf(data.etf) : <Etf>this.etf; 
            this.inav = data.inav && !(<any>data.inav).toJSON ? new Inav(data.inav) : <Inav>this.inav; 
            this.fund = data.fund && !(<any>data.fund).toJSON ? new Fund(data.fund) : <Fund>this.fund; 
            this.index = data.index && !(<any>data.index).toJSON ? new Index(data.index) : <Index>this.index; 
        }
        if (!data) {
            this.type = InstrumentType.Undefined;
            this.mic = ExchangeMic.Xxxx;
        }
    }

    init(data?: any) {
        if (data) {
            this.symbol = data["Symbol"];
            this.name = data["Name"];
            this.description = data["Description"];
            this.type = data["Type"];
            this.mic = data["Mic"];
            this.isin = data["Isin"];
            this.stock = data["Stock"] ? Stock.fromJS(data["Stock"]) : <any>undefined;
            this.etv = data["Etv"] ? Etv.fromJS(data["Etv"]) : <any>undefined;
            this.etf = data["Etf"] ? Etf.fromJS(data["Etf"]) : <any>undefined;
            this.inav = data["Inav"] ? Inav.fromJS(data["Inav"]) : <any>undefined;
            this.fund = data["Fund"] ? Fund.fromJS(data["Fund"]) : <any>undefined;
            this.index = data["Index"] ? Index.fromJS(data["Index"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Instrument2 {
        data = typeof data === 'object' ? data : {};
        let result = new Instrument2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Symbol"] = this.symbol;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Type"] = this.type;
        data["Mic"] = this.mic;
        data["Isin"] = this.isin;
        data["Stock"] = this.stock ? this.stock.toJSON() : <any>undefined;
        data["Etv"] = this.etv ? this.etv.toJSON() : <any>undefined;
        data["Etf"] = this.etf ? this.etf.toJSON() : <any>undefined;
        data["Inav"] = this.inav ? this.inav.toJSON() : <any>undefined;
        data["Fund"] = this.fund ? this.fund.toJSON() : <any>undefined;
        data["Index"] = this.index ? this.index.toJSON() : <any>undefined;
        return data; 
    }
}

/** Contains information to describe an instrument. */
export interface IInstrument2 {
    /** Gets or sets the optional symbol (ticker) of the security. */
    symbol?: string | undefined;
    /** Gets or sets a name of the instrument. */
    name?: string | undefined;
    /** Gets or sets an optional textual description for the instrument. */
    description?: string | undefined;
    /** Gets or sets the instrument type. */
    type: InstrumentType;
    /** Gets or sets an exchange representations according to ISO 10383 Market Identifier Code (MIC). */
    mic: ExchangeMic;
    /** Gets or sets an ISIN. */
    isin?: string | undefined;
    /** Gets or sets an additional information for stocks. */
    stock?: IStock | undefined;
    /** Gets or sets an additional information for Exchange-Traded Vehicles. */
    etv?: IEtv | undefined;
    /** Gets or sets an additional information for Exchange-Traded Funds. */
    etf?: IEtf | undefined;
    /** Gets or sets an additional information for Indicative Net Asset Values. */
    inav?: IInav | undefined;
    /** Gets or sets an additional information for funds. */
    fund?: IFund | undefined;
    /** Gets or sets an additional information for indices. */
    index?: IIndex | undefined;
}

/** An additional information for stocks. */
export class Stock implements IStock {
    /** Gets or sets a currency code. */
    currency!: CurrencyCode;
    /** Gets or sets a trading mode. */
    tradingMode?: string | undefined;
    /** Gets or sets an ISO 10962 Classification of Financial Instruments code. */
    cfi?: string | undefined;
    /** Gets or sets an Industry Classification Benchmark code. */
    icb?: string | undefined;
    /** Gets or sets a number of shares outstanding. */
    sharesOutstanding!: number;

    constructor(data?: IStock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["Currency"];
            this.tradingMode = data["TradingMode"];
            this.cfi = data["Cfi"];
            this.icb = data["Icb"];
            this.sharesOutstanding = data["SharesOutstanding"];
        }
    }

    static fromJS(data: any): Stock {
        data = typeof data === 'object' ? data : {};
        let result = new Stock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Currency"] = this.currency;
        data["TradingMode"] = this.tradingMode;
        data["Cfi"] = this.cfi;
        data["Icb"] = this.icb;
        data["SharesOutstanding"] = this.sharesOutstanding;
        return data; 
    }
}

/** An additional information for stocks. */
export interface IStock {
    /** Gets or sets a currency code. */
    currency: CurrencyCode;
    /** Gets or sets a trading mode. */
    tradingMode?: string | undefined;
    /** Gets or sets an ISO 10962 Classification of Financial Instruments code. */
    cfi?: string | undefined;
    /** Gets or sets an Industry Classification Benchmark code. */
    icb?: string | undefined;
    /** Gets or sets a number of shares outstanding. */
    sharesOutstanding: number;
}

/** An additional information for Exchange-Traded Vehicles. */
export class Etv implements IEtv {
    /** Gets or sets a currency code. */
    currency!: CurrencyCode;
    /** Gets or sets a trading mode. */
    tradingMode?: string | undefined;
    /** Gets or sets all-in fees. */
    allInFees?: string | undefined;
    /** Gets or sets an expence ratio percentage. */
    expenseRatio?: string | undefined;
    /** Gets or sets a dividend frequency. */
    dividendFrequency?: string | undefined;
    /** Gets or sets an issuer. */
    issuer?: string | undefined;
    /** Gets or sets a number of shares outstanding. */
    sharesOutstanding!: number;

    constructor(data?: IEtv) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["Currency"];
            this.tradingMode = data["TradingMode"];
            this.allInFees = data["AllInFees"];
            this.expenseRatio = data["ExpenseRatio"];
            this.dividendFrequency = data["DividendFrequency"];
            this.issuer = data["Issuer"];
            this.sharesOutstanding = data["SharesOutstanding"];
        }
    }

    static fromJS(data: any): Etv {
        data = typeof data === 'object' ? data : {};
        let result = new Etv();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Currency"] = this.currency;
        data["TradingMode"] = this.tradingMode;
        data["AllInFees"] = this.allInFees;
        data["ExpenseRatio"] = this.expenseRatio;
        data["DividendFrequency"] = this.dividendFrequency;
        data["Issuer"] = this.issuer;
        data["SharesOutstanding"] = this.sharesOutstanding;
        return data; 
    }
}

/** An additional information for Exchange-Traded Vehicles. */
export interface IEtv {
    /** Gets or sets a currency code. */
    currency: CurrencyCode;
    /** Gets or sets a trading mode. */
    tradingMode?: string | undefined;
    /** Gets or sets all-in fees. */
    allInFees?: string | undefined;
    /** Gets or sets an expence ratio percentage. */
    expenseRatio?: string | undefined;
    /** Gets or sets a dividend frequency. */
    dividendFrequency?: string | undefined;
    /** Gets or sets an issuer. */
    issuer?: string | undefined;
    /** Gets or sets a number of shares outstanding. */
    sharesOutstanding: number;
}

/** An additional information for Exchange-Traded Funds. */
export class Etf implements IEtf {
    /** Gets or sets a currency code. */
    currency!: CurrencyCode;
    /** Gets or sets a trading mode. */
    tradingMode?: string | undefined;
    /** Gets or sets an ISO 10962 Classification of Financial Instruments code. */
    cfi?: string | undefined;
    /** Gets or sets a dividend frequency. */
    dividendFrequency?: string | undefined;
    /** Gets or sets an exposition type. */
    expositionType?: string | undefined;
    /** Gets or sets a fraction. */
    fraction?: string | undefined;
    /** Gets or sets a total expence ratio percentage. */
    totalExpenseRatio?: string | undefined;
    /** Gets or sets an index family. */
    indexFamily?: string | undefined;
    /** Gets or sets a launch date. */
    launchDate?: string | undefined;
    /** Gets or sets an issuer. */
    issuer?: string | undefined;
    /** Gets or sets an Indicative Net Asset Value instrument reference. */
    inav?: InstrumentReference | undefined;
    /** Gets or sets an underlying instrument reference. */
    underlying?: InstrumentReference | undefined;

    constructor(data?: IEtf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.inav = data.inav && !(<any>data.inav).toJSON ? new InstrumentReference(data.inav) : <InstrumentReference>this.inav; 
            this.underlying = data.underlying && !(<any>data.underlying).toJSON ? new InstrumentReference(data.underlying) : <InstrumentReference>this.underlying; 
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["Currency"];
            this.tradingMode = data["TradingMode"];
            this.cfi = data["Cfi"];
            this.dividendFrequency = data["DividendFrequency"];
            this.expositionType = data["ExpositionType"];
            this.fraction = data["Fraction"];
            this.totalExpenseRatio = data["TotalExpenseRatio"];
            this.indexFamily = data["IndexFamily"];
            this.launchDate = data["LaunchDate"];
            this.issuer = data["Issuer"];
            this.inav = data["Inav"] ? InstrumentReference.fromJS(data["Inav"]) : <any>undefined;
            this.underlying = data["Underlying"] ? InstrumentReference.fromJS(data["Underlying"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Etf {
        data = typeof data === 'object' ? data : {};
        let result = new Etf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Currency"] = this.currency;
        data["TradingMode"] = this.tradingMode;
        data["Cfi"] = this.cfi;
        data["DividendFrequency"] = this.dividendFrequency;
        data["ExpositionType"] = this.expositionType;
        data["Fraction"] = this.fraction;
        data["TotalExpenseRatio"] = this.totalExpenseRatio;
        data["IndexFamily"] = this.indexFamily;
        data["LaunchDate"] = this.launchDate;
        data["Issuer"] = this.issuer;
        data["Inav"] = this.inav ? this.inav.toJSON() : <any>undefined;
        data["Underlying"] = this.underlying ? this.underlying.toJSON() : <any>undefined;
        return data; 
    }
}

/** An additional information for Exchange-Traded Funds. */
export interface IEtf {
    /** Gets or sets a currency code. */
    currency: CurrencyCode;
    /** Gets or sets a trading mode. */
    tradingMode?: string | undefined;
    /** Gets or sets an ISO 10962 Classification of Financial Instruments code. */
    cfi?: string | undefined;
    /** Gets or sets a dividend frequency. */
    dividendFrequency?: string | undefined;
    /** Gets or sets an exposition type. */
    expositionType?: string | undefined;
    /** Gets or sets a fraction. */
    fraction?: string | undefined;
    /** Gets or sets a total expence ratio percentage. */
    totalExpenseRatio?: string | undefined;
    /** Gets or sets an index family. */
    indexFamily?: string | undefined;
    /** Gets or sets a launch date. */
    launchDate?: string | undefined;
    /** Gets or sets an issuer. */
    issuer?: string | undefined;
    /** Gets or sets an Indicative Net Asset Value instrument reference. */
    inav?: IInstrumentReference | undefined;
    /** Gets or sets an underlying instrument reference. */
    underlying?: IInstrumentReference | undefined;
}

/** Contains information to reference an instrument. */
export class InstrumentReference implements IInstrumentReference {
    /** Gets or sets an exchange representations according to ISO 10383 Market Identifier Code (MIC). */
    mic?: string | undefined;
    /** Gets or sets an ISIN. */
    isin?: string | undefined;
    /** Gets or sets the optional symbol (ticker) of the security. */
    symbol?: string | undefined;
    /** Gets or sets a name of the instrument. */
    name?: string | undefined;

    constructor(data?: IInstrumentReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mic = data["Mic"];
            this.isin = data["Isin"];
            this.symbol = data["Symbol"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): InstrumentReference {
        data = typeof data === 'object' ? data : {};
        let result = new InstrumentReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Mic"] = this.mic;
        data["Isin"] = this.isin;
        data["Symbol"] = this.symbol;
        data["Name"] = this.name;
        return data; 
    }
}

/** Contains information to reference an instrument. */
export interface IInstrumentReference {
    /** Gets or sets an exchange representations according to ISO 10383 Market Identifier Code (MIC). */
    mic?: string | undefined;
    /** Gets or sets an ISIN. */
    isin?: string | undefined;
    /** Gets or sets the optional symbol (ticker) of the security. */
    symbol?: string | undefined;
    /** Gets or sets a name of the instrument. */
    name?: string | undefined;
}

/** An additional information for Indicative Net Asset Values. */
export class Inav implements IInav {
    /** Gets or sets a currency code. */
    currency!: CurrencyCode;
    /** Gets or sets a target instrument reference. */
    target?: InstrumentReference | undefined;

    constructor(data?: IInav) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.target = data.target && !(<any>data.target).toJSON ? new InstrumentReference(data.target) : <InstrumentReference>this.target; 
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["Currency"];
            this.target = data["Target"] ? InstrumentReference.fromJS(data["Target"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Inav {
        data = typeof data === 'object' ? data : {};
        let result = new Inav();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Currency"] = this.currency;
        data["Target"] = this.target ? this.target.toJSON() : <any>undefined;
        return data; 
    }
}

/** An additional information for Indicative Net Asset Values. */
export interface IInav {
    /** Gets or sets a currency code. */
    currency: CurrencyCode;
    /** Gets or sets a target instrument reference. */
    target?: IInstrumentReference | undefined;
}

/** An additional information for funds. */
export class Fund implements IFund {
    /** Gets or sets a currency code. */
    currency!: CurrencyCode;
    /** Gets or sets a trading mode. */
    tradingMode?: string | undefined;
    /** Gets or sets an ISO 10962 Classification of Financial Instruments code. */
    cfi?: string | undefined;
    /** Gets or sets an issuer. */
    issuer?: string | undefined;
    /** Gets or sets a number of shares outstanding. */
    sharesOutstanding!: number;

    constructor(data?: IFund) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["Currency"];
            this.tradingMode = data["TradingMode"];
            this.cfi = data["Cfi"];
            this.issuer = data["Issuer"];
            this.sharesOutstanding = data["SharesOutstanding"];
        }
    }

    static fromJS(data: any): Fund {
        data = typeof data === 'object' ? data : {};
        let result = new Fund();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Currency"] = this.currency;
        data["TradingMode"] = this.tradingMode;
        data["Cfi"] = this.cfi;
        data["Issuer"] = this.issuer;
        data["SharesOutstanding"] = this.sharesOutstanding;
        return data; 
    }
}

/** An additional information for funds. */
export interface IFund {
    /** Gets or sets a currency code. */
    currency: CurrencyCode;
    /** Gets or sets a trading mode. */
    tradingMode?: string | undefined;
    /** Gets or sets an ISO 10962 Classification of Financial Instruments code. */
    cfi?: string | undefined;
    /** Gets or sets an issuer. */
    issuer?: string | undefined;
    /** Gets or sets a number of shares outstanding. */
    sharesOutstanding: number;
}

/** An additional information for indices. */
export class Index implements IIndex {
    /** Gets or sets a currency code. */
    currency!: CurrencyCode;
    /** Gets or sets a kind of an index. */
    kind?: string | undefined;
    /** Gets or sets a family of an index. */
    family?: string | undefined;
    /** Gets or sets a calculation frequency of an index. */
    calculationFrequency?: string | undefined;
    /** Gets or sets a weighting of an index. */
    weighting?: string | undefined;
    /** Gets or sets a capping factor of an index. */
    cappingFactor?: string | undefined;
    /** Gets or sets an Industry Classification Benchmark code. */
    icb?: string | undefined;
    /** Gets or sets a base date of an index. */
    baseDate?: string | undefined;
    /** Gets or sets a base level of an index. */
    baseLevel?: string | undefined;

    constructor(data?: IIndex) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["Currency"];
            this.kind = data["Kind"];
            this.family = data["Family"];
            this.calculationFrequency = data["CalculationFrequency"];
            this.weighting = data["Weighting"];
            this.cappingFactor = data["CappingFactor"];
            this.icb = data["Icb"];
            this.baseDate = data["BaseDate"];
            this.baseLevel = data["BaseLevel"];
        }
    }

    static fromJS(data: any): Index {
        data = typeof data === 'object' ? data : {};
        let result = new Index();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Currency"] = this.currency;
        data["Kind"] = this.kind;
        data["Family"] = this.family;
        data["CalculationFrequency"] = this.calculationFrequency;
        data["Weighting"] = this.weighting;
        data["CappingFactor"] = this.cappingFactor;
        data["Icb"] = this.icb;
        data["BaseDate"] = this.baseDate;
        data["BaseLevel"] = this.baseLevel;
        return data; 
    }
}

/** An additional information for indices. */
export interface IIndex {
    /** Gets or sets a currency code. */
    currency: CurrencyCode;
    /** Gets or sets a kind of an index. */
    kind?: string | undefined;
    /** Gets or sets a family of an index. */
    family?: string | undefined;
    /** Gets or sets a calculation frequency of an index. */
    calculationFrequency?: string | undefined;
    /** Gets or sets a weighting of an index. */
    weighting?: string | undefined;
    /** Gets or sets a capping factor of an index. */
    cappingFactor?: string | undefined;
    /** Gets or sets an Industry Classification Benchmark code. */
    icb?: string | undefined;
    /** Gets or sets a base date of an index. */
    baseDate?: string | undefined;
    /** Gets or sets a base level of an index. */
    baseLevel?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}

}