using System;
using System.Buffers;
using System.Buffers.Text;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.IO.Pipelines;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using Mbs.Trading.Data.Entities;
using Mbs.Trading.Instruments;
using Mbs.Trading.Time;
using Mbs.Utilities;

namespace Mbs.Trading.Data.Historical.Providers.Csv
{
    /// <summary>
    /// Csv data repository utilities.
    /// </summary>
    public static class CsvHistoricalData
    {
        /// <summary>
        /// The data provider name.
        /// </summary>
        internal const string Provider = "Csv";

        private const string Prefix = "CsvHistoricalData";

        private static readonly object CacheDictionaryLock = new object();
        private static readonly Dictionary<string, InstrumentCsvInfo> InfoCacheDictionary = new Dictionary<string, InstrumentCsvInfo>();

        /// <summary>
        /// Adds an instrument with an associated csv info to the repository.
        /// </summary>
        /// <param name="instrument">The instrument to add.</param>
        /// <param name="csvInfo">The csv info to add.</param>
        public static void Add(Instrument instrument, CsvInfo csvInfo)
        {
            string file = csvInfo.FilePath;
            if (string.IsNullOrWhiteSpace(file) || !File.Exists(file))
            {
                Log.Error(FileDoesNotExist(file));
                return;
            }

            string key = Key(instrument);
            lock (CacheDictionaryLock)
            {
                if (!InfoCacheDictionary.TryGetValue(key, out var instrumentCsvInfo))
                {
                    instrumentCsvInfo = new InstrumentCsvInfo();
                    InfoCacheDictionary.Add(key, instrumentCsvInfo);
                }

                instrumentCsvInfo.Add(csvInfo);
            }
        }

        /// <summary>
        /// Gets the instrument CSV info or <c>null</c> if not found.
        /// </summary>
        /// <param name="instrument">The instrument to find.</param>
        /// <returns>The CSV info or null if not found.</returns>
        internal static InstrumentCsvInfo InstrumentInfo(Instrument instrument)
        {
            string key = Key(instrument);
            var instrumentInfo = FindInstrument(key);
            if (instrumentInfo == null)
            {
                Log.Error(MissingInstrument(key));
            }

            return instrumentInfo;
        }

        /// <summary>
        /// Given a <see cref="CsvInfo"/>, enumerates <see cref="Ohlcv"/> elements asynchronously.
        /// </summary>
        /// <param name="csvInfo">The csv info.</param>
        /// <param name="csvRequest">The csv request.</param>
        /// <param name="cancellationToken">An optional cancellation token.</param>
        /// <returns>An asynchronous enumerable interface.</returns>
        internal static IEnumerable<Ohlcv> EnumerateOhlcvAsync(CsvInfo csvInfo, CsvRequest csvRequest, CancellationToken cancellationToken = default)
        {
            IEnumerable<Ohlcv> enumerable;
            try
            {
                enumerable = EnumerateOhlcvFileAsync(csvInfo, csvRequest, cancellationToken);
            }
            catch (Exception ex)
            {
                Log.Error(ErrorReadingFile(csvInfo.FilePath), ex);
                yield break;
            }

            using IEnumerator<Ohlcv> enumerator = enumerable.GetEnumerator();
            while (true)
            {
                try
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                }
                catch (Exception ex)
                {
                    Log.Error(ErrorReadingFile(csvInfo.FilePath), ex);
                    break;
                }

                yield return enumerator.Current;
            }
        }

        internal static async IAsyncEnumerable<Ohlcv> EnumerateOhlcvAsyncE(CsvInfo csvInfo, CsvRequest csvRequest, [EnumeratorCancellation] CancellationToken cancellationToken)
        {
            var hasEndofdayClosingTime = csvRequest.EndofdayClosingTime.HasValue;
            var info = new Info(csvInfo, csvRequest);
            long lineNumber = 0;

            await using var fileStream = File.OpenRead(csvInfo.FilePath);
            var pipeReader = PipeReader.Create(fileStream);
            while (true)
            {
                ReadResult read = await pipeReader.ReadAsync(cancellationToken);
                ReadOnlySequence<byte> buffer = read.Buffer;
                while (TryReadSequence(ref buffer, out ReadOnlySequence<byte> sequence))
                {
                    ++lineNumber;
                    var errorMessage = ProcessSequence(sequence, info, out Ohlcv ohlcv);
                    if (errorMessage == null)
                    {
                        if (ohlcv != null)
                        {
                            if (hasEndofdayClosingTime)
                            {
                                ohlcv.Time = ohlcv.Time.Date.Add(csvRequest.EndofdayClosingTime.Value);
                            }

                            yield return ohlcv;
                        }
                    }
                    else if (errorMessage.Length == 0)
                    {
                        yield break;
                    }
                    else
                    {
                        errorMessage = $"{Prefix}: file {csvInfo.FilePath}, line {lineNumber}: {errorMessage}, aborted";
                        Log.Error(errorMessage);
                        throw new AggregateException(errorMessage);
                    }
                }

                pipeReader.AdvanceTo(buffer.Start, buffer.End);
                if (read.IsCompleted)
                {
                    yield break;
                }
            }
        }

        /// <summary>
        /// Given a <see cref="CsvInfo"/>, enumerates <see cref="Scalar"/> elements asynchronously.
        /// </summary>
        /// <param name="csvInfo">The csv info.</param>
        /// <param name="csvRequest">The csv request.</param>
        /// <param name="cancellationToken">An optional cancellation token.</param>
        /// <returns>An asynchronous enumerable interface.</returns>
        internal static IEnumerable<Scalar> EnumerateScalarAsync(CsvInfo csvInfo, CsvRequest csvRequest, CancellationToken cancellationToken = default)
        {
            IEnumerable<Scalar> enumerable;
            try
            {
                enumerable = EnumerateScalarFileAsync(csvInfo, csvRequest, cancellationToken);
            }
            catch (Exception ex)
            {
                Log.Error(ErrorReadingFile(csvInfo.FilePath), ex);
                yield break;
            }

            using IEnumerator<Scalar> enumerator = enumerable.GetEnumerator();
            while (true)
            {
                try
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                }
                catch (Exception ex)
                {
                    Log.Error(ErrorReadingFile(csvInfo.FilePath), ex);
                    break;
                }

                yield return enumerator.Current;
            }
        }

        /// <summary>
        /// Given a <see cref="CsvInfo"/>, enumerates <see cref="Trade"/> elements asynchronously.
        /// </summary>
        /// <param name="csvInfo">The csv info.</param>
        /// <param name="csvRequest">The csv request.</param>
        /// <param name="cancellationToken">An optional cancellation token.</param>
        /// <returns>An asynchronous enumerable interface.</returns>
        internal static IEnumerable<Trade> EnumerateTradeAsync(CsvInfo csvInfo, CsvRequest csvRequest, CancellationToken cancellationToken = default)
        {
            IEnumerable<Trade> enumerable;
            try
            {
                enumerable = EnumerateTradeFileAsync(csvInfo, csvRequest, cancellationToken);
            }
            catch (Exception ex)
            {
                Log.Error(ErrorReadingFile(csvInfo.FilePath), ex);
                yield break;
            }

            using IEnumerator<Trade> enumerator = enumerable.GetEnumerator();
            while (true)
            {
                try
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                }
                catch (Exception ex)
                {
                    Log.Error(ErrorReadingFile(csvInfo.FilePath), ex);
                    break;
                }

                yield return enumerator.Current;
            }
        }

        /// <summary>
        /// Given a <see cref="CsvInfo"/>, enumerates <see cref="Quote"/> elements asynchronously.
        /// </summary>
        /// <param name="csvInfo">The csv info.</param>
        /// <param name="csvRequest">The csv request.</param>
        /// <param name="cancellationToken">An optional cancellation token.</param>
        /// <returns>An asynchronous enumerable interface.</returns>
        internal static IEnumerable<Quote> EnumerateQuoteAsync(CsvInfo csvInfo, CsvRequest csvRequest, CancellationToken cancellationToken = default)
        {
            IEnumerable<Quote> enumerable;
            try
            {
                enumerable = EnumerateQuoteFileAsync(csvInfo, csvRequest, cancellationToken);
            }
            catch (Exception ex)
            {
                Log.Error(ErrorReadingFile(csvInfo.FilePath), ex);
                yield break;
            }

            using IEnumerator<Quote> enumerator = enumerable.GetEnumerator();
            while (true)
            {
                try
                {
                    if (!enumerator.MoveNext())
                    {
                        break;
                    }
                }
                catch (Exception ex)
                {
                    Log.Error(ErrorReadingFile(csvInfo.FilePath), ex);
                    break;
                }

                yield return enumerator.Current;
            }
        }

        /// <summary>
        /// Gets an error message.
        /// </summary>
        /// <param name="timeGranularity">The time granularity.</param>
        /// <returns>The error message.</returns>
        internal static string CannotComposeGranularity(TimeGranularity timeGranularity)
        {
            return $"{Prefix}: cannot compose the requested time granularity {timeGranularity}.";
        }

        /// <summary>
        /// Gets an error message.
        /// </summary>
        /// <param name="timeGranularity">The time granularity.</param>
        /// <param name="name">The name of an entity.</param>
        /// <returns>The error message.</returns>
        internal static string TimeGranularityNotSupported(TimeGranularity timeGranularity, string name)
        {
            return $"{Prefix}: time granularity {timeGranularity} is not supported for {name} entities";
        }

        /// <summary>
        /// Gets an error message.
        /// </summary>
        /// <param name="name">The name of an entity.</param>
        /// <returns>The error message.</returns>
        internal static string InstrumentHasNoData(string name)
        {
            return $"{Prefix}: the specified instrument has no {name} data";
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string Key(string mic, string symbol, string isin)
        {
            isin = isin?.ToUpperInvariant() ?? string.Empty;
            symbol = symbol?.ToUpperInvariant() ?? string.Empty;
            mic = mic?.ToUpperInvariant() ?? string.Empty;

            return string.Concat(symbol, "-", isin, "@", mic);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string Key(Instrument instrument)
        {
            return Key(
                instrument.Exchange.Mic.ToString(),
                instrument.Symbol,
                instrument.GetSecurityIdAs(InstrumentSecurityIdSource.Isin));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static InstrumentCsvInfo FindInstrument(string key)
        {
            lock (CacheDictionaryLock)
            {
                return InfoCacheDictionary.TryGetValue(key, out var instrumentCsvInfo)
                    ? instrumentCsvInfo
                    : null;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static IEnumerable<Ohlcv> EnumerateOhlcvFileAsync(CsvInfo csvInfo, CsvRequest csvRequest, CancellationToken cancellationToken)
        {
            bool hasVolume = csvInfo.HasVolume;
            bool hasHighLow = csvInfo.HasHighLow;
            char commentChar = csvInfo.CommentCharacter;
            string delimiter = csvInfo.SeparatorCharacter;

            long lineNumber = 0L;
            using var fileStream = File.Open(csvInfo.FilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            using var bufferedStream = new BufferedStream(fileStream);
            using var streamReader = new StreamReader(bufferedStream, Encoding.UTF8);
            string line;
            while ((line = streamReader.ReadLine()) != null)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    Log.Warning($"{Prefix}: Cancellation requested in [{line}], line number {lineNumber}, file path {csvInfo.FilePath}");
                    break;
                }

                ++lineNumber;
                if (line.Length == 0 || line[0] == commentChar)
                {
                    continue;
                }

                var error = ParseOhlcvSpan(csvInfo, csvRequest, line, delimiter, hasVolume, hasHighLow, out Ohlcv ohlcv, out CsvEnumerationAction action);
                if (error == null)
                {
                    if (action == CsvEnumerationAction.Continue)
                    {
                        yield return ohlcv;
                    }
                    else if (action == CsvEnumerationAction.Break)
                    {
                        break;
                    }

                    continue;
                }

                Log.Error($"{Prefix}: {error} in [{line}], line number {lineNumber}, file path {csvInfo.FilePath}");
                break;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string ParseOhlcvSpan(CsvInfo csvInfo, CsvRequest csvRequest, string line, string delimiter, bool hasVolume, bool hasHighLow, out Ohlcv ohlcv, out CsvEnumerationAction action)
        {
            ohlcv = null;
            action = CsvEnumerationAction.Continue;
            var lineSpan = line.AsSpan();
            var dateTimeFormatSpan = csvInfo.DateTimeFormat.AsSpan();
            var delimiterSpan = delimiter.AsSpan();
            int i = lineSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (i < 0)
            {
                return CannotFindDelimiter(delimiter);
            }

            var span = lineSpan.Slice(0, i);
            if (!DateTime.TryParseExact(span, dateTimeFormatSpan, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dateTime))
            {
                return InvalidDateTimePart(span);
            }

            if (csvRequest.EndofdayClosingTime.HasValue)
            {
                dateTime = dateTime.Date.Add(csvRequest.EndofdayClosingTime.Value);
            }

            if (dateTime < csvRequest.StartDateTime)
            {
                action = CsvEnumerationAction.Skip;
                return null;
            }

            if (dateTime > csvRequest.EndDateTime)
            {
                action = CsvEnumerationAction.Break;
                return null;
            }

            var currentSpan = lineSpan.Slice(++i);
            i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (i < 0)
            {
                return CannotFindDelimiter(delimiter, currentSpan);
            }

            span = currentSpan.Slice(0, i);
            if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out double open, out _))
            {
                return InvalidPart("opening price", span, currentSpan);
            }

            double high = double.NaN, low = double.NaN;
            if (hasHighLow)
            {
                currentSpan = currentSpan.Slice(++i);
                i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
                if (i < 0)
                {
                    return CannotFindDelimiter(delimiter, currentSpan);
                }

                span = currentSpan.Slice(0, i);
                if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out high, out _))
                {
                    return InvalidPart("highest price", span, currentSpan);
                }

                currentSpan = currentSpan.Slice(++i);
                i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
                if (i < 0)
                {
                    return CannotFindDelimiter(delimiter, currentSpan);
                }

                span = currentSpan.Slice(0, i);
                if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out low, out _))
                {
                    return InvalidPart("lowest price", span, currentSpan);
                }
            }

            currentSpan = currentSpan.Slice(++i);
            i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (hasVolume)
            {
                if (i < 0)
                {
                    return CannotFindDelimiter(delimiter, currentSpan);
                }

                span = currentSpan.Slice(0, i);
            }
            else
            {
                span = i < 0 ? currentSpan : currentSpan.Slice(0, i);
            }

            if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out double close, out _))
            {
                return InvalidPart("closing price", span, currentSpan);
            }

            if (!hasHighLow)
            {
                low = Math.Min(open, close);
                high = Math.Max(open, close);
            }

            double volume = double.NaN;
            if (hasVolume)
            {
                currentSpan = currentSpan.Slice(++i);
                i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
                span = i < 0 ? currentSpan : currentSpan.Slice(0, i);
                if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out volume, out _))
                {
                    return InvalidPart("volume", span, currentSpan);
                }
            }

            ohlcv = new Ohlcv(dateTime, open, high, low, close, volume);
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static IEnumerable<Scalar> EnumerateScalarFileAsync(CsvInfo csvInfo, CsvRequest csvRequest, CancellationToken cancellationToken)
        {
            char commentChar = csvInfo.CommentCharacter;
            string delimiter = csvInfo.SeparatorCharacter;

            long lineNumber = 0L;
            using var fileStream = File.Open(csvInfo.FilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            using var bufferedStream = new BufferedStream(fileStream);
            using var streamReader = new StreamReader(bufferedStream, Encoding.UTF8);
            string line;
            while ((line = streamReader.ReadLine()) != null)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    Log.Warning($"{Prefix}: Cancellation requested in [{line}], line number {lineNumber}, file path {csvInfo.FilePath}");
                    break;
                }

                ++lineNumber;
                if (line.Length == 0 || line[0] == commentChar)
                {
                    continue;
                }

                var error = ParseScalarSpan(csvInfo, csvRequest, line, delimiter, out Scalar scalar, out CsvEnumerationAction action);
                if (error == null)
                {
                    if (action == CsvEnumerationAction.Continue)
                    {
                        yield return scalar;
                    }
                    else if (action == CsvEnumerationAction.Break)
                    {
                        break;
                    }

                    continue;
                }

                Log.Error($"{Prefix}: {error} in [{line}], line number {lineNumber}, file path {csvInfo.FilePath}");
                break;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string ParseScalarSpan(CsvInfo csvInfo, CsvRequest csvRequest, string line, string delimiter, out Scalar scalar, out CsvEnumerationAction action)
        {
            scalar = null;
            action = CsvEnumerationAction.Continue;
            var lineSpan = line.AsSpan();
            var dateTimeFormatSpan = csvInfo.DateTimeFormat.AsSpan();
            var delimiterSpan = delimiter.AsSpan();
            int i = lineSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (i < 0)
            {
                return CannotFindDelimiter(delimiter);
            }

            var span = lineSpan.Slice(0, i);
            if (!DateTime.TryParseExact(span, dateTimeFormatSpan, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dateTime))
            {
                return InvalidDateTimePart(span);
            }

            if (csvRequest.EndofdayClosingTime.HasValue)
            {
                dateTime = dateTime.Date.Add(csvRequest.EndofdayClosingTime.Value);
            }

            if (dateTime < csvRequest.StartDateTime)
            {
                action = CsvEnumerationAction.Skip;
                return null;
            }

            if (dateTime > csvRequest.EndDateTime)
            {
                action = CsvEnumerationAction.Break;
                return null;
            }

            var currentSpan = lineSpan.Slice(++i);
            i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            span = i < 0 ? currentSpan : currentSpan.Slice(0, i);
            if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out double value, out _))
            {
                return InvalidPart("value", span, currentSpan);
            }

            scalar = new Scalar(dateTime, value);
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static IEnumerable<Trade> EnumerateTradeFileAsync(CsvInfo csvInfo, CsvRequest csvRequest, CancellationToken cancellationToken)
        {
            bool hasVolume = csvInfo.HasVolume;
            char commentChar = csvInfo.CommentCharacter;
            string delimiter = csvInfo.SeparatorCharacter;

            long lineNumber = 0L;
            using var fileStream = File.Open(csvInfo.FilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            using var bufferedStream = new BufferedStream(fileStream);
            using var streamReader = new StreamReader(bufferedStream, Encoding.UTF8);
            string line;
            while ((line = streamReader.ReadLine()) != null)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    Log.Warning($"{Prefix}: Cancellation requested in [{line}], line number {lineNumber}, file path {csvInfo.FilePath}");
                    break;
                }

                ++lineNumber;
                if (line.Length == 0 || line[0] == commentChar)
                {
                    continue;
                }

                var error = ParseTradeSpan(csvInfo, csvRequest, line, delimiter, hasVolume, out Trade trade, out CsvEnumerationAction action);
                if (error == null)
                {
                    if (action == CsvEnumerationAction.Continue)
                    {
                        yield return trade;
                    }
                    else if (action == CsvEnumerationAction.Break)
                    {
                        break;
                    }

                    continue;
                }

                Log.Error($"{Prefix}: {error} in [{line}], line number {lineNumber}, file path {csvInfo.FilePath}");
                break;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string ParseTradeSpan(CsvInfo csvInfo, CsvRequest csvRequest, string line, string delimiter, bool hasVolume, out Trade trade, out CsvEnumerationAction action)
        {
            trade = null;
            action = CsvEnumerationAction.Continue;
            var lineSpan = line.AsSpan();
            var dateTimeFormatSpan = csvInfo.DateTimeFormat.AsSpan();
            var delimiterSpan = delimiter.AsSpan();
            int i = lineSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (i < 0)
            {
                return CannotFindDelimiter(delimiter);
            }

            var span = lineSpan.Slice(0, i);
            if (!DateTime.TryParseExact(span, dateTimeFormatSpan, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dateTime))
            {
                return InvalidDateTimePart(span);
            }

            if (dateTime < csvRequest.StartDateTime)
            {
                action = CsvEnumerationAction.Skip;
                return null;
            }

            if (dateTime > csvRequest.EndDateTime)
            {
                action = CsvEnumerationAction.Break;
                return null;
            }

            var currentSpan = lineSpan.Slice(++i);
            i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (hasVolume)
            {
                if (i < 0)
                {
                    return CannotFindDelimiter(delimiter, currentSpan);
                }

                span = currentSpan.Slice(0, i);
            }
            else
            {
                span = i < 0 ? currentSpan : currentSpan.Slice(0, i);
            }

            if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out double price, out _))
            {
                return InvalidPart("price", span, currentSpan);
            }

            double volume;
            if (hasVolume)
            {
                currentSpan = currentSpan.Slice(++i);
                i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
                span = i < 0 ? currentSpan : currentSpan.Slice(0, i);
                if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out volume, out _))
                {
                    return InvalidPart("volume", span, currentSpan);
                }
            }
            else
            {
                volume = double.NaN;
            }

            trade = new Trade(dateTime, price, volume);
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static IEnumerable<Quote> EnumerateQuoteFileAsync(CsvInfo csvInfo, CsvRequest csvRequest, CancellationToken cancellationToken)
        {
            bool hasVolume = csvInfo.HasVolume;
            char commentChar = csvInfo.CommentCharacter;
            string delimiter = csvInfo.SeparatorCharacter;

            long lineNumber = 0L;
            using var fileStream = File.Open(csvInfo.FilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            using var bufferedStream = new BufferedStream(fileStream);
            using var streamReader = new StreamReader(bufferedStream, Encoding.UTF8);
            string line;
            while ((line = streamReader.ReadLine()) != null)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    Log.Warning($"{Prefix}: Cancellation requested in [{line}], line number {lineNumber}, file path {csvInfo.FilePath}");
                    break;
                }

                ++lineNumber;
                if (line.Length == 0 || line[0] == commentChar)
                {
                    continue;
                }

                var error = ParseQuoteSpan(csvInfo, csvRequest, line, delimiter, hasVolume, out Quote quote, out CsvEnumerationAction action);
                if (error == null)
                {
                    if (action == CsvEnumerationAction.Continue)
                    {
                        yield return quote;
                    }
                    else if (action == CsvEnumerationAction.Break)
                    {
                        break;
                    }

                    continue;
                }

                Log.Error($"{Prefix}: {error} in [{line}], line number {lineNumber}, file path {csvInfo.FilePath}");
                break;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string ParseQuoteSpan(CsvInfo csvInfo, CsvRequest csvRequest, string line, string delimiter, bool hasVolume, out Quote quote, out CsvEnumerationAction action)
        {
            quote = null;
            action = CsvEnumerationAction.Continue;
            var lineSpan = line.AsSpan();
            var dateTimeFormatSpan = csvInfo.DateTimeFormat.AsSpan();
            var delimiterSpan = delimiter.AsSpan();
            int i = lineSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (i < 0)
            {
                return CannotFindDelimiter(delimiter);
            }

            var span = lineSpan.Slice(0, i);
            if (!DateTime.TryParseExact(span, dateTimeFormatSpan, CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime dateTime))
            {
                return InvalidDateTimePart(span);
            }

            if (csvRequest.EndofdayClosingTime.HasValue)
            {
                dateTime = dateTime.Date.Add(csvRequest.EndofdayClosingTime.Value);
            }

            if (dateTime < csvRequest.StartDateTime)
            {
                action = CsvEnumerationAction.Skip;
                return null;
            }

            if (dateTime > csvRequest.EndDateTime)
            {
                action = CsvEnumerationAction.Break;
                return null;
            }

            var currentSpan = lineSpan.Slice(++i);
            i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (i < 0)
            {
                return CannotFindDelimiter(delimiter, currentSpan);
            }

            span = currentSpan.Slice(0, i);
            if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out double askPrice, out _))
            {
                return InvalidPart("ask price", span, currentSpan);
            }

            currentSpan = currentSpan.Slice(++i);
            i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
            if (hasVolume)
            {
                if (i < 0)
                {
                    return CannotFindDelimiter(delimiter, currentSpan);
                }

                span = currentSpan.Slice(0, i);
            }
            else
            {
                span = i < 0 ? currentSpan : currentSpan.Slice(0, i);
            }

            if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out double bidPrice, out _))
            {
                return InvalidPart("bid price", span, currentSpan);
            }

            double askSize = double.NaN, bidSize = double.NaN;
            if (hasVolume)
            {
                currentSpan = currentSpan.Slice(++i);
                i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
                if (i < 0)
                {
                    return CannotFindDelimiter(delimiter, currentSpan);
                }

                span = currentSpan.Slice(0, i);
                if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out askSize, out _))
                {
                    return InvalidPart("ask size", span, currentSpan);
                }

                currentSpan = currentSpan.Slice(++i);
                i = currentSpan.IndexOf(delimiterSpan, StringComparison.Ordinal);
                span = i < 0 ? currentSpan : currentSpan.Slice(0, i);
                if (!Utf8Parser.TryParse(Encoding.UTF8.GetBytes(span.ToArray()), out bidSize, out _))
                {
                    return InvalidPart("bid size", span, currentSpan);
                }
            }

            quote = new Quote(dateTime, bidPrice, bidSize, askPrice, askSize);
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static bool TryReadSequence(ref ReadOnlySequence<byte> buffer, out ReadOnlySequence<byte> sequence)
        {
            var position = buffer.PositionOf((byte)'\n');
            if (position == null)
            {
                sequence = default;
                return false;
            }

            sequence = buffer.Slice(0, position.Value);
            buffer = buffer.Slice(buffer.GetPosition(1, position.Value));
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static string ProcessSequence(ReadOnlySequence<byte> sequence, Info info, out Ohlcv ohlcv)
        {
            if (sequence.IsSingleSegment)
            {
                return Parse(sequence.FirstSpan, info, out ohlcv);
            }

            const int lengthLimit = 5120;
            var length = sequence.Length;
            if (length < lengthLimit)
            {
                Span<byte> span = stackalloc byte[(int)sequence.Length];
                sequence.CopyTo(span);
                return Parse(span, info, out ohlcv);
            }

            var buffer = ArrayPool<byte>.Shared.Rent((int)length);
            sequence.CopyTo(buffer);
            var errorCode = Parse(buffer, info, out ohlcv);
            ArrayPool<byte>.Shared.Return(buffer);
            return errorCode;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static string ProcessSequence(ReadOnlySequence<byte> sequence, Info info, out Scalar scalar)
        {
            if (sequence.IsSingleSegment)
            {
                return Parse(sequence.FirstSpan, info, out scalar);
            }

            const int lengthLimit = 5120;
            var length = sequence.Length;
            if (length < lengthLimit)
            {
                Span<byte> span = stackalloc byte[(int)sequence.Length];
                sequence.CopyTo(span);
                return Parse(span, info, out scalar);
            }

            var buffer = ArrayPool<byte>.Shared.Rent((int)length);
            sequence.CopyTo(buffer);
            var errorCode = Parse(buffer, info, out scalar);
            ArrayPool<byte>.Shared.Return(buffer);
            return errorCode;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static string ProcessSequence(ReadOnlySequence<byte> sequence, Info info, out Trade trade)
        {
            if (sequence.IsSingleSegment)
            {
                return Parse(sequence.FirstSpan, info, out trade);
            }

            const int lengthLimit = 5120;
            var length = sequence.Length;
            if (length < lengthLimit)
            {
                Span<byte> span = stackalloc byte[(int)sequence.Length];
                sequence.CopyTo(span);
                return Parse(span, info, out trade);
            }

            var buffer = ArrayPool<byte>.Shared.Rent((int)length);
            sequence.CopyTo(buffer);
            var errorCode = Parse(buffer, info, out trade);
            ArrayPool<byte>.Shared.Return(buffer);
            return errorCode;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static string ProcessSequence(ReadOnlySequence<byte> sequence, Info info, out Quote quote)
        {
            if (sequence.IsSingleSegment)
            {
                return Parse(sequence.FirstSpan, info, out quote);
            }

            const int lengthLimit = 5120;
            var length = sequence.Length;
            if (length < lengthLimit)
            {
                Span<byte> span = stackalloc byte[(int)sequence.Length];
                sequence.CopyTo(span);
                return Parse(span, info, out quote);
            }

            var buffer = ArrayPool<byte>.Shared.Rent((int)length);
            sequence.CopyTo(buffer);
            var errorCode = Parse(buffer, info, out quote);
            ArrayPool<byte>.Shared.Return(buffer);
            return errorCode;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static ReadOnlySpan<byte> ParseChunk(byte delimiter, ref ReadOnlySpan<byte> span, ref int scanned, ref int position)
        {
            scanned += position + 1;

            position = span[scanned..].IndexOf(delimiter);
            if (position < 0)
            {
                var sp = span[scanned..];
                position = sp.Length;

                // The last chunk in a line might be terminated by the '\r'.
                return (!sp.IsEmpty && sp[^1] == (byte)'\r')
                    ? sp[..^1]
                    : sp;
            }

            return span.Slice(scanned, position);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string Parse(ReadOnlySpan<byte> bytes, Info info, out Ohlcv ohlcv)
        {
            ohlcv = null;

            // Empty line might contain '\r'.
            if (bytes.Length < 2 || bytes[0] == info.Comment)
            {
                return null;
            }

            int scanned = -1;
            int position = 0;

            var span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            string errorMessage = TryParseDateTime(span, info.TimeFormat, out DateTime dateTime, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            if (dateTime < info.StartDateInclusive)
            {
                return null;
            }

            if (dateTime > info.EndDateInclusive)
            {
                return string.Empty;
            }

            span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            errorMessage = TryParseDouble(span, "opening price", out double open, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            double high, low, close, volume;
            if (info.HasHighLow)
            {
                span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
                errorMessage = TryParseDouble(span, "highest price", out high, bytes);
                if (errorMessage != null)
                {
                    return errorMessage;
                }

                span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
                errorMessage = TryParseDouble(span, "lowest price", out low, bytes);
                if (errorMessage != null)
                {
                    return errorMessage;
                }

                span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
                errorMessage = TryParseDouble(span, "closing price", out close, bytes);
                if (errorMessage != null)
                {
                    return errorMessage;
                }
            }
            else
            {
                span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
                errorMessage = TryParseDouble(span, "closing price", out close, bytes);
                if (errorMessage != null)
                {
                    return errorMessage;
                }

                high = Math.Max(open, close);
                low = Math.Min(open, close);
            }

            if (info.HasVolume)
            {
                span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
                errorMessage = TryParseDouble(span, "volume", out volume, bytes);
                if (errorMessage != null)
                {
                    return errorMessage;
                }
            }
            else
            {
                volume = 0;
            }

            ohlcv = new Ohlcv(dateTime, open, high, low, close, volume);
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string Parse(ReadOnlySpan<byte> bytes, Info info, out Scalar scalar)
        {
            scalar = null;

            // Empty line might contain '\r'.
            if (bytes.Length < 2 || bytes[0] == info.Comment)
            {
                return null;
            }

            int scanned = -1;
            int position = 0;

            var span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            string errorMessage = TryParseDateTime(span, info.TimeFormat, out DateTime dateTime, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            if (dateTime < info.StartDateInclusive)
            {
                return null;
            }

            if (dateTime > info.EndDateInclusive)
            {
                return string.Empty;
            }

            span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            errorMessage = TryParseDouble(span, "scalar", out double value, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            scalar = new Scalar(dateTime, value);
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string Parse(ReadOnlySpan<byte> bytes, Info info, out Trade trade)
        {
            trade = null;

            // Empty line might contain '\r'.
            if (bytes.Length < 2 || bytes[0] == info.Comment)
            {
                return null;
            }

            int scanned = -1;
            int position = 0;

            var span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            string errorMessage = TryParseDateTime(span, info.TimeFormat, out DateTime dateTime, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            if (dateTime < info.StartDateInclusive)
            {
                return null;
            }

            if (dateTime > info.EndDateInclusive)
            {
                return string.Empty;
            }

            span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            errorMessage = TryParseDouble(span, "price", out double price, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            double volume;
            if (info.HasVolume)
            {
                span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
                errorMessage = TryParseDouble(span, "volume", out volume, bytes);
                if (errorMessage != null)
                {
                    return errorMessage;
                }
            }
            else
            {
                volume = 0;
            }

            trade = new Trade(dateTime, price, volume);
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization & MethodImplOptions.InternalCall)]
        private static string Parse(ReadOnlySpan<byte> bytes, Info info, out Quote quote)
        {
            quote = null;

            // Empty line might contain '\r'.
            if (bytes.Length < 2 || bytes[0] == info.Comment)
            {
                return null;
            }

            int scanned = -1;
            int position = 0;

            var span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            string errorMessage = TryParseDateTime(span, info.TimeFormat, out DateTime dateTime, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            if (dateTime < info.StartDateInclusive)
            {
                return null;
            }

            if (dateTime > info.EndDateInclusive)
            {
                return string.Empty;
            }

            span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            errorMessage = TryParseDouble(span, "ask price", out double askPrice, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
            errorMessage = TryParseDouble(span, "bid price", out double bidPrice, bytes);
            if (errorMessage != null)
            {
                return errorMessage;
            }

            double askSize, bidSize;
            if (info.HasVolume)
            {
                span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
                errorMessage = TryParseDouble(span, "ask size", out askSize, bytes);
                if (errorMessage != null)
                {
                    return errorMessage;
                }

                span = ParseChunk(info.Delimiter, ref bytes, ref scanned, ref position);
                errorMessage = TryParseDouble(span, "bid size", out bidSize, bytes);
                if (errorMessage != null)
                {
                    return errorMessage;
                }
            }
            else
            {
                askSize = 0;
                bidSize = 0;
            }

            quote = new Quote(dateTime, bidPrice, bidSize, askPrice, askSize);
            return null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static string TryParseDateTime(ReadOnlySpan<byte> span, string timeFormat, out DateTime dateTime, ReadOnlySpan<byte> line)
        {
            if (!span.IsEmpty)
            {
                Span<char> chars = stackalloc char[span.Length];
                Encoding.UTF8.GetChars(span, chars);
                if (DateTime.TryParseExact(chars, timeFormat, CultureInfo.InvariantCulture, DateTimeStyles.None, out dateTime))
                {
                    return null;
                }
            }

            dateTime = new DateTime(0L);
            return $"Invalid date-time [{timeFormat}] part [{ByteSpanToString(span)}] in [{ByteSpanToString(line)}]";
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static string TryParseDouble(ReadOnlySpan<byte> span, string what, out double value, ReadOnlySpan<byte> line)
        {
            // 18.g29 => 18
            // if (!span.IsEmpty && Utf8Parser.TryParse(span, out value, out _, 'f')) return null
            if (!span.IsEmpty && (value = ParsePositiveDouble(span)) >= 0)
            {
                return null;
            }

            value = ParsePositiveDouble(span);
            return value < 0 ? $"Invalid {what} part [{ByteSpanToString(span)}] in [{ByteSpanToString(line)}]" : null;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining & MethodImplOptions.AggressiveOptimization)]
        private static double ParsePositiveDouble(ReadOnlySpan<byte> span)
        {
            if (span.IsEmpty)
            {
                return -1;
            }

            double v = 0;
            double factor = 1;
            bool pointSeen = false;

            foreach (var b in span)
            {
                if (b == (byte)'-')
                {
                    if (span[0] != b)
                    {
                        return -1;
                    }

                    factor *= -1;
                    continue;
                }

                if (b == (byte)'.')
                {
                    if (pointSeen)
                    {
                        return -1;
                    }

                    pointSeen = true;
                    continue;
                }

                if (b < (byte)'0' || b > (byte)'9')
                {
                    return -1;
                }

                v = v * 10 + b - (byte)'0';
                if (pointSeen)
                {
                    factor /= 10;
                }
            }

            return v * factor;
        }

        private static string ByteSpanToString(ReadOnlySpan<byte> span)
        {
            if (span.IsEmpty)
            {
                return string.Empty;
            }

            Span<char> chars = stackalloc char[span.Length];
            Encoding.UTF8.GetChars(span, chars);
            return chars.ToString();
        }

        private static string FileDoesNotExist(string csvFile)
        {
            return $"{Prefix}: file {csvFile} does not exist";
        }

        private static string MissingInstrument(string key)
        {
            return $"{Prefix}: failed to find instrument {key}";
        }

        private static string ErrorReadingFile(string file)
        {
            return $"{Prefix}: exception while reading file {file}";
        }

        private static string CannotFindDelimiter(string delimiter)
        {
            return $"Cannot find delimiter {delimiter}";
        }

        private static string CannotFindDelimiter(string delimiter, ReadOnlySpan<char> currentSpan)
        {
            return $"Cannot find delimiter {delimiter} in [{currentSpan.ToString()}]";
        }

        private static string InvalidDateTimePart(ReadOnlySpan<char> span)
        {
            return $"Invalid date-time part [{span.ToString()}]";
        }

        private static string InvalidPart(string name, ReadOnlySpan<char> span, ReadOnlySpan<char> currentSpan)
        {
            return $"Invalid {name} [{span.ToString()}] in [{currentSpan.ToString()}]";
        }

        private class Info
        {
            public Info(CsvInfo csvInfo, CsvRequest csvRequest)
            {
                Comment = csvInfo.HasCommentCharacter ? (byte)csvInfo.CommentCharacter : (byte)0;
                Delimiter = (byte)csvInfo.SeparatorCharacter[0];
                TimeFormat = csvInfo.DateTimeFormat ?? CsvInfo.DefaultDateTimeFormat;
                StartDateInclusive = csvRequest.StartDateTime;
                EndDateInclusive = csvRequest.EndDateTime;
                HasVolume = csvInfo.HasVolume;
                HasHighLow = csvInfo.HasHighLow;
            }

            public byte Comment { get; }

            public byte Delimiter { get; }

            public string TimeFormat { get; }

            public DateTime StartDateInclusive { get; }

            public DateTime EndDateInclusive { get; }

            public bool HasVolume { get; }

            public bool HasHighLow { get; }
        }
    }
}
